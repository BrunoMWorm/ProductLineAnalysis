
==================== FINAL INTERFACE ====================
2019-03-10 04:20:04.532588 UTC

interface SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL [hpc] 8063
  interface hash: 1b9d2a0e3a8040958e5fcc883da452e6
  ABI hash: 29367586413bfaa8069c603b144284ac
  export-list hash: 40369a917ec8447fc0e3b995fdab7421
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2cfdad7a135455f74853ec2a67c2f080
  opt_hash: 5835274e0c52a5d281a4b935bfdb5c93
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  SPL.===
  SPL.====
  SPL.apply
  SPL.apply_
  SPL.compact
  SPL.compactEq
  SPL.cond
  SPL.cond'
  SPL.definedAt
  SPL.exists
  SPL.filterLifted
  SPL.findVal
  SPL.getAllConfigs
  SPL.getValidConfigs
  SPL.groupVals
  SPL.groupVals_
  SPL.index
  SPL.inv
  SPL.isSubsetOf
  SPL.liftA4
  SPL.liftA5
  SPL.liftV
  SPL.liftV2
  SPL.liftV3
  SPL.liftV4
  SPL.liftV5
  SPL.mapLifted
  SPL.mkVar
  SPL.mkVarT
  SPL.mkVars
  SPL.pairs
  SPL.phelem
  SPL.restrict
  SPL.subst
  SPL.undefinedAt
  SPL.union
  SPL.union2
  SPL.unions
  SPL.valIndex
  SPL.|+|
  SPL.|:|
  SPL.|==|
  SPL.PresenceCondition
  SPL.Val
  SPL.Var{SPL.Var}
module dependencies: PropBDD
package dependencies: array-0.5.3.0 base-4.12.0.0
                      containers-0.6.0.1 cudd-0.1.0.4 deepseq-1.4.4.0 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0 parallel-3.2.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Set.Internal
import  -/  PropBDD 26340779dada9254b6fa27adf741484c
  exports: e66a3ac1040f7241f5d9a8b0e3f63d04
  Prop 0cb8b07c97187edb8f9f9eee81c5f0d8
  conj 1197108a188c79bd6158d8c5950f2993
  disj 1b91eda1850e60a4ad61f372e64c20ff
  implies 23e0cd77bfc19211bbe702f6f2de9d71
  neg 694869409f8cd198db3f842ddb9d8c0b
  sat 7650a737238435fb3efc82aa6f4041d8
  tt d7dbb7fb65c834182f53a455dcb03ff1
  unsat ee71168ee681ca6a8fe82fcf8352f433
import  -/  base-4.12.0.0:Control.Applicative f4c86ba32601955aaee0c0abccbaeade
import  -/  base-4.12.0.0:Control.Exception 9037ab3ff61dd8119bebad992e069fdd
import  -/  base-4.12.0.0:Control.Monad 7bd27be8172a0ce3a579caee3ae14f88
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.List ce2c69da408fdc014383cede9e1f9adf
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.IO.Unsafe b9716290bd560f0c4b285e916a56af21
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:GHC.StableName 9edc9e69895694f8e48a9bb6ce1640f2
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  base-4.12.0.0:System.IO.Unsafe 557ea6d3b6b3c4b4f565668cbd563e94
import  -/  base-4.12.0.0:System.Mem.StableName cbeca862bb17be0b0c1f844130a94e94
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  parallel-3.2.2.0:Control.Parallel.Strategies a570e9026407cdb6c276d3e7ed3ec3ca
475a314e24adb901a231766e201ad80e
  $fApplicativeVar :: GHC.Base.Applicative SPL.Var
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SPL.Var
                  SPL.$fFunctorVar
                  SPL.$fApplicativeVar_$cpure
                  SPL.$fApplicativeVar_$c<*>
                  SPL.$fApplicativeVar_$cliftA2
                  SPL.$fApplicativeVar_$c*>
                  SPL.$fApplicativeVar_$c<* -}
0a55135076f87fede39e4185ad3eca3d
  $fApplicativeVar1 :: [SPL.Val (a -> b -> a)]
  {- Strictness: m2,
     Unfolding: (\ @ a @ b ->
                 GHC.Types.:
                   @ (SPL.Val (a -> b -> a))
                   (SPL.$fApplicativeVar2 @ b @ a)
                   (GHC.Types.[] @ (SPL.Val (a -> b -> a)))) -}
b15e110bfc767bc75b7094c2d8bd9171
  $fApplicativeVar2 :: (a -> b -> a, SPL.PresenceCondition)
  {- Strictness: m,
     Unfolding: (\ @ b @ a -> (GHC.Base.const @ a @ b, PropBDD.tt)) -}
0919a3dd444142c782842bbb130c1de6
  $fApplicativeVar3 :: [SPL.Val (a -> b -> b)]
  {- Strictness: m2,
     Unfolding: (\ @ a @ b ->
                 GHC.Types.:
                   @ (SPL.Val (a -> b -> b))
                   (SPL.$fApplicativeVar4 @ a @ b)
                   (GHC.Types.[] @ (SPL.Val (a -> b -> b)))) -}
2e5631bac62c3138b9cb58b4a0d322d1
  $fApplicativeVar4 :: (a -> b -> b, SPL.PresenceCondition)
  {- Strictness: m,
     Unfolding: (\ @ a @ b ->
                 (SPL.$fApplicativeVar5 @ b @ a, PropBDD.tt)) -}
f4fafc1f972d69ed791b97e7540e2b64
  $fApplicativeVar5 :: a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ b @ a (ds :: a) (eta :: b) -> eta) -}
475a314e24adb901a231766e201ad80e
  $fApplicativeVar_$c*> :: SPL.Var a -> SPL.Var b -> SPL.Var b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (a1 :: SPL.Var a) (a2 :: SPL.Var b) ->
                 SPL.$fApplicativeVar_$c<*>
                   @ b
                   @ b
                   (({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                       @ a
                                                                                       @ (b -> b)
                                                                                       (SPL.$fApplicativeVar3
                                                                                          @ a
                                                                                          @ b)
                                                                                         `cast`
                                                                                       (Sym (SPL.N:Var[0]
                                                                                                 <a
                                                                                                  -> b
                                                                                                  -> b>_R)))
                      a1)
                   a2) -}
475a314e24adb901a231766e201ad80e
  $fApplicativeVar_$c<* :: SPL.Var a -> SPL.Var b -> SPL.Var a
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (x :: SPL.Var a) ->
                 SPL.$fApplicativeVar_$c<*>
                   @ b
                   @ a
                   (({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                       @ a
                                                                                       @ (b -> a)
                                                                                       (SPL.$fApplicativeVar1
                                                                                          @ a
                                                                                          @ b)
                                                                                         `cast`
                                                                                       (Sym (SPL.N:Var[0]
                                                                                                 <a
                                                                                                  -> b
                                                                                                  -> a>_R)))
                      x)) -}
475a314e24adb901a231766e201ad80e
  $fApplicativeVar_$c<*> ::
    SPL.Var (a -> b) -> SPL.Var a -> SPL.Var b
  {- Unfolding: ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.<*>} True False} SPL.apply) -}
475a314e24adb901a231766e201ad80e
  $fApplicativeVar_$cliftA2 ::
    (a -> b -> c) -> SPL.Var a -> SPL.Var b -> SPL.Var c
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b @ c (f1 :: a -> b -> c) (x :: SPL.Var a) ->
                 SPL.$fApplicativeVar_$c<*>
                   @ b
                   @ c
                   (({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                       @ a
                                                                                       @ (b -> c)
                                                                                       (SPL.mkVarT
                                                                                          @ (a
                                                                                             -> b
                                                                                             -> c)
                                                                                          f1))
                      x)) -}
475a314e24adb901a231766e201ad80e
  $fApplicativeVar_$cpure :: a -> SPL.Var a
  {- Unfolding: ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.pure} True False} SPL.mkVarT) -}
475a314e24adb901a231766e201ad80e
  $fEqVar :: GHC.Classes.Eq a => GHC.Classes.Eq (SPL.Var a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (SPL.Var a) (SPL.$fEqVar_$c== @ a v) (SPL.$fEqVar_$c/= @ a v) -}
475a314e24adb901a231766e201ad80e
  $fEqVar1 ::
    GHC.Classes.Eq t =>
    SPL.Var t -> SPL.Var t -> Data.Semigroup.Internal.All
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   ($dEq :: GHC.Classes.Eq t)
                   (ds :: SPL.Var t)
                   (y' :: SPL.Var t) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.isSubsetOf} True True} letrec {
                                                                                         go :: [(t,
                                                                                                 SPL.PresenceCondition)]
                                                                                               -> Data.Semigroup.Internal.All
                                                                                           <join 1> {- Arity: 1 -}
                                                                                         = \ (ds1 :: [(t,
                                                                                                       SPL.PresenceCondition)]) ->
                                                                                           case ds1 of wild {
                                                                                             []
                                                                                             -> GHC.Types.True
                                                                                                  `cast`
                                                                                                (Sym (Data.Semigroup.Internal.N:All[0]))
                                                                                             : y ys
                                                                                             -> case SPL.exists
                                                                                                       @ t
                                                                                                       $dEq
                                                                                                       y
                                                                                                       y' of wild1 {
                                                                                                  GHC.Types.False
                                                                                                  -> GHC.Types.False
                                                                                                       `cast`
                                                                                                     (Sym (Data.Semigroup.Internal.N:All[0]))
                                                                                                  GHC.Types.True
                                                                                                  -> go
                                                                                                       ys } }
                                                                                       } in
                                                                                       go
                                                                                         ds
                                                                                           `cast`
                                                                                         (SPL.N:Var[0]
                                                                                              <t>_R)) -}
475a314e24adb901a231766e201ad80e
  $fEqVar_$c/= ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: SPL.Var a)
                   (y :: SPL.Var a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL./=} True True} case ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.==} True True} SPL.$fEqVar1
                                                                                                                                                     @ a
                                                                                                                                                     $dEq
                                                                                                                                                     x
                                                                                                                                                     y)
                                                                                      `cast`
                                                                                    (Data.Semigroup.Internal.N:All[0]) of wild {
                                                                                 GHC.Types.False
                                                                                 -> GHC.Types.True
                                                                                 GHC.Types.True
                                                                                 -> case ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.==} False True} SPL.$fEqVar1
                                                                                                                                                           @ a
                                                                                                                                                           $dEq
                                                                                                                                                           y
                                                                                                                                                           x)
                                                                                           `cast`
                                                                                         (Data.Semigroup.Internal.N:All[0]) of wild1 {
                                                                                      GHC.Types.False
                                                                                      -> GHC.Types.True
                                                                                      GHC.Types.True
                                                                                      -> GHC.Types.False } }) -}
475a314e24adb901a231766e201ad80e
  $fEqVar_$c== ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: SPL.Var a)
                   (y :: SPL.Var a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.==} True True} case {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.isSubsetOf} True True} letrec {
                                                                                                                                                            go :: [(a,
                                                                                                                                                                    SPL.PresenceCondition)]
                                                                                                                                                                  -> GHC.Types.Bool
                                                                                                                                                              <join 1> {- Arity: 1,
                                                                                                                                                                          Strictness: <S,1*U> -}
                                                                                                                                                            = \ (ds :: [(a,
                                                                                                                                                                         SPL.PresenceCondition)]) ->
                                                                                                                                                              case ds of wild {
                                                                                                                                                                []
                                                                                                                                                                -> GHC.Types.True
                                                                                                                                                                : y1 ys
                                                                                                                                                                -> case y1 of ww { (,) ww1 ww2 ->
                                                                                                                                                                   case SPL.$wexists
                                                                                                                                                                          @ a
                                                                                                                                                                          $dEq
                                                                                                                                                                          ww1
                                                                                                                                                                          ww2
                                                                                                                                                                          y of wild1 {
                                                                                                                                                                     GHC.Types.False
                                                                                                                                                                     -> GHC.Types.False
                                                                                                                                                                     GHC.Types.True
                                                                                                                                                                     -> go
                                                                                                                                                                          ys } } }
                                                                                                                                                          } in
                                                                                                                                                          go
                                                                                                                                                            x `cast`
                                                                                                                                                            (SPL.N:Var[0]
                                                                                                                                                                 <a>_R) of wild {
                                                                                 GHC.Types.False
                                                                                 -> GHC.Types.False
                                                                                 GHC.Types.True
                                                                                 -> (SPL.$fEqVar1
                                                                                       @ a
                                                                                       $dEq
                                                                                       y
                                                                                       x)
                                                                                      `cast`
                                                                                    (Data.Semigroup.Internal.N:All[0]) }) -}
475a314e24adb901a231766e201ad80e
  $fFunctorVar :: GHC.Base.Functor SPL.Var
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ SPL.Var SPL.$fFunctorVar_$cfmap SPL.$fFunctorVar_$c<$ -}
475a314e24adb901a231766e201ad80e
  $fFunctorVar_$c<$ :: a -> SPL.Var b -> SPL.Var a
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (x :: a) ->
                 let {
                   f :: b -> a {- Arity: 1 -} = \ (ds :: b) -> x
                 } in
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                   @ b
                                                                                   @ a
                                                                                   (GHC.Types.:
                                                                                      @ (SPL.Val
                                                                                           (b -> a))
                                                                                      (f,
                                                                                       PropBDD.tt)
                                                                                      (GHC.Types.[]
                                                                                         @ (SPL.Val
                                                                                              (b
                                                                                               -> a))))
                                                                                     `cast`
                                                                                   (Sym (SPL.N:Var[0]
                                                                                             <b
                                                                                              -> a>_R))) -}
475a314e24adb901a231766e201ad80e
  $fFunctorVar_$cfmap :: (a -> b) -> SPL.Var a -> SPL.Var b
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (f :: a -> b) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                   @ a
                                                                                   @ b
                                                                                   (SPL.mkVarT
                                                                                      @ (a -> b)
                                                                                      f)) -}
475a314e24adb901a231766e201ad80e
  $fOrdVar :: GHC.Classes.Eq a => GHC.Classes.Ord (SPL.Var a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (SPL.Var a)
                  (SPL.$fEqVar @ a v)
                  (SPL.$fOrdVar_$ccompare @ a v)
                  (SPL.$fOrdVar_$c< @ a v)
                  (SPL.$fOrdVar_$c<= @ a v)
                  (SPL.$fOrdVar_$c> @ a v)
                  (SPL.$fOrdVar_$c>= @ a v)
                  (SPL.$fOrdVar_$cmax @ a v)
                  (SPL.$fOrdVar_$cmin @ a v) -}
475a314e24adb901a231766e201ad80e
  $fOrdVar_$c< ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x' :: SPL.Var a)
                   (y' :: SPL.Var a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.<} True True} case {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.isSubsetOf} True True} letrec {
                                                                                                                                                           go :: [(a,
                                                                                                                                                                   SPL.PresenceCondition)]
                                                                                                                                                                 -> GHC.Types.Bool
                                                                                                                                                             <join 1> {- Arity: 1,
                                                                                                                                                                         Strictness: <S,1*U> -}
                                                                                                                                                           = \ (ds :: [(a,
                                                                                                                                                                        SPL.PresenceCondition)]) ->
                                                                                                                                                             case ds of wild {
                                                                                                                                                               []
                                                                                                                                                               -> GHC.Types.True
                                                                                                                                                               : y ys
                                                                                                                                                               -> case y of ww { (,) ww1 ww2 ->
                                                                                                                                                                  case SPL.$wexists
                                                                                                                                                                         @ a
                                                                                                                                                                         $dEq
                                                                                                                                                                         ww1
                                                                                                                                                                         ww2
                                                                                                                                                                         y' of wild1 {
                                                                                                                                                                    GHC.Types.False
                                                                                                                                                                    -> GHC.Types.False
                                                                                                                                                                    GHC.Types.True
                                                                                                                                                                    -> go
                                                                                                                                                                         ys } } }
                                                                                                                                                         } in
                                                                                                                                                         go
                                                                                                                                                           x'
                                                                                                                                                             `cast`
                                                                                                                                                           (SPL.N:Var[0]
                                                                                                                                                                <a>_R) of wild {
                                                                                GHC.Types.False
                                                                                -> GHC.Types.False
                                                                                GHC.Types.True
                                                                                -> case {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.isSubsetOf} True True} letrec {
                                                                                                                                                                go :: [(a,
                                                                                                                                                                        SPL.PresenceCondition)]
                                                                                                                                                                      -> GHC.Types.Bool
                                                                                                                                                                  <join 1> {- Arity: 1,
                                                                                                                                                                              Strictness: <S,1*U> -}
                                                                                                                                                                = \ (ds :: [(a,
                                                                                                                                                                             SPL.PresenceCondition)]) ->
                                                                                                                                                                  case ds of wild1 {
                                                                                                                                                                    []
                                                                                                                                                                    -> GHC.Types.True
                                                                                                                                                                    : y ys
                                                                                                                                                                    -> case y of ww { (,) ww1 ww2 ->
                                                                                                                                                                       case SPL.$wexists
                                                                                                                                                                              @ a
                                                                                                                                                                              $dEq
                                                                                                                                                                              ww1
                                                                                                                                                                              ww2
                                                                                                                                                                              x' of wild2 {
                                                                                                                                                                         GHC.Types.False
                                                                                                                                                                         -> GHC.Types.False
                                                                                                                                                                         GHC.Types.True
                                                                                                                                                                         -> go
                                                                                                                                                                              ys } } }
                                                                                                                                                              } in
                                                                                                                                                              go
                                                                                                                                                                y'
                                                                                                                                                                  `cast`
                                                                                                                                                                (SPL.N:Var[0]
                                                                                                                                                                     <a>_R) of wild1 {
                                                                                     GHC.Types.False
                                                                                     -> GHC.Types.True
                                                                                     GHC.Types.True
                                                                                     -> GHC.Types.False } }) -}
475a314e24adb901a231766e201ad80e
  $fOrdVar_$c<= ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: SPL.Var a)
                   (y :: SPL.Var a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.<=} True True} case ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.<} True True} SPL.$fEqVar1
                                                                                                                                                    @ a
                                                                                                                                                    $dEq
                                                                                                                                                    x
                                                                                                                                                    y)
                                                                                      `cast`
                                                                                    (Data.Semigroup.Internal.N:All[0]) of wild {
                                                                                 GHC.Types.False
                                                                                 -> SPL.$fEqVar_$c==
                                                                                      @ a
                                                                                      $dEq
                                                                                      x
                                                                                      y
                                                                                 GHC.Types.True
                                                                                 -> case ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.<} False True} SPL.$fEqVar1
                                                                                                                                                          @ a
                                                                                                                                                          $dEq
                                                                                                                                                          y
                                                                                                                                                          x)
                                                                                           `cast`
                                                                                         (Data.Semigroup.Internal.N:All[0]) of wild1 {
                                                                                      GHC.Types.False
                                                                                      -> GHC.Types.True
                                                                                      GHC.Types.True
                                                                                      -> SPL.$fEqVar_$c==
                                                                                           @ a
                                                                                           $dEq
                                                                                           x
                                                                                           y } }) -}
475a314e24adb901a231766e201ad80e
  $fOrdVar_$c> ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: SPL.Var a)
                   (y :: SPL.Var a) ->
                 case SPL.$fOrdVar_$ccompare @ a $dEq x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
475a314e24adb901a231766e201ad80e
  $fOrdVar_$c>= ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: SPL.Var a)
                   (y :: SPL.Var a) ->
                 case SPL.$fOrdVar_$ccompare @ a $dEq x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
475a314e24adb901a231766e201ad80e
  $fOrdVar_$ccompare ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> GHC.Types.Ordering
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: SPL.Var a)
                   (y :: SPL.Var a) ->
                 case ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.==} True True} SPL.$fEqVar1
                                                                                       @ a
                                                                                       $dEq
                                                                                       x
                                                                                       y)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False
                   -> case SPL.$fOrdVar_$c<= @ a $dEq x y of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.LT }
                   GHC.Types.True
                   -> case ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.==} False True} SPL.$fEqVar1
                                                                                             @ a
                                                                                             $dEq
                                                                                             y
                                                                                             x)
                             `cast`
                           (Data.Semigroup.Internal.N:All[0]) of wild1 {
                        GHC.Types.False
                        -> case SPL.$fOrdVar_$c<= @ a $dEq x y of wild2 {
                             GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.LT }
                        GHC.Types.True -> GHC.Types.EQ } }) -}
475a314e24adb901a231766e201ad80e
  $fOrdVar_$cmax ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> SPL.Var a
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: SPL.Var a)
                   (y :: SPL.Var a) ->
                 case SPL.$fOrdVar_$c<= @ a $dEq x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
475a314e24adb901a231766e201ad80e
  $fOrdVar_$cmin ::
    GHC.Classes.Eq a => SPL.Var a -> SPL.Var a -> SPL.Var a
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: SPL.Var a)
                   (y :: SPL.Var a) ->
                 case SPL.$fOrdVar_$c<= @ a $dEq x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
475a314e24adb901a231766e201ad80e
  $fShowVar :: GHC.Show.Show a => GHC.Show.Show (SPL.Var a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C1(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (SPL.Var a)
                  (SPL.$fShowVar_$cshowsPrec @ a v)
                  (SPL.$fShowVar_$cshow @ a v)
                  (SPL.$fShowVar_$cshowList @ a v) -}
f7d4d011e61fb069c23bdde05a69a3a1
  $fShowVar1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# SPL.$fShowVar2) -}
663547b365df49dd0a2ff0569287b3e5
  $fShowVar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
f911ef2b52c0fb007cd5c6eb17651b19
  $fShowVar3 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.$fShow(,)2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
76fbb55c7368d8dd938ff16fc5c6dad8
  $fShowVar4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# SPL.$fShowVar5) -}
f1ca6bf21188632e0630696177f888e9
  $fShowVar5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
0503bf5549a4875e4947a992751299a7
  $fShowVar6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{\n"#) -}
475a314e24adb901a231766e201ad80e
  $fShowVar_$cshow :: GHC.Show.Show a => SPL.Var a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C1(U))),A,A)><L,U>,
     Unfolding: (\ @ a ($dShow :: GHC.Show.Show a) (v' :: SPL.Var a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.show} True True} GHC.CString.unpackAppendCString#
                                                                                   SPL.$fShowVar6
                                                                                   (letrec {
                                                                                      go :: [(a,
                                                                                              SPL.PresenceCondition)]
                                                                                            -> [GHC.Types.Char]
                                                                                        {- Arity: 1,
                                                                                           Strictness: <S,1*U> -}
                                                                                      = \ (ds :: [(a,
                                                                                                   SPL.PresenceCondition)]) ->
                                                                                        case ds of wild {
                                                                                          []
                                                                                          -> GHC.Types.[]
                                                                                               @ GHC.Types.Char
                                                                                          : y ys
                                                                                          -> GHC.Base.++
                                                                                               @ GHC.Types.Char
                                                                                               ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.show.\} True True} case y of ww { (,) ww1 ww2 ->
                                                                                                                                                                  GHC.Base.++_$s++
                                                                                                                                                                    @ GHC.Types.Char
                                                                                                                                                                    SPL.$fShowVar4
                                                                                                                                                                    GHC.Show.$fShow(,)4
                                                                                                                                                                    (GHC.Show.showsPrec
                                                                                                                                                                       @ a
                                                                                                                                                                       $dShow
                                                                                                                                                                       GHC.Show.$fShow(,)1
                                                                                                                                                                       ww1
                                                                                                                                                                       (GHC.Types.:
                                                                                                                                                                          @ GHC.Types.Char
                                                                                                                                                                          GHC.Show.showList__1
                                                                                                                                                                          (GHC.Show.$fShow(,)_$sgo1
                                                                                                                                                                             SPL.$fShowVar3
                                                                                                                                                                             (Cudd.Cudd.$w$cshowsPrec
                                                                                                                                                                                0#
                                                                                                                                                                                ww2)
                                                                                                                                                                             (GHC.Types.[]
                                                                                                                                                                                @ GHC.Show.ShowS)))) })
                                                                                               (go
                                                                                                  ys) }
                                                                                    } in
                                                                                    {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.show.v} True False} GHC.Base.++
                                                                                                                                                         @ GHC.Types.Char
                                                                                                                                                         (go
                                                                                                                                                            ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.show.(...)} True True} SPL.compact
                                                                                                                                                                                                                                     @ a
                                                                                                                                                                                                                                     v')
                                                                                                                                                              `cast`
                                                                                                                                                            (SPL.N:Var[0]
                                                                                                                                                                 <a>_R))
                                                                                                                                                         SPL.$fShowVar1)) -}
475a314e24adb901a231766e201ad80e
  $fShowVar_$cshowList ::
    GHC.Show.Show a => [SPL.Var a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C1(U))),A,A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [SPL.Var a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (SPL.Var a)
                   (\ (x :: SPL.Var a) (s1 :: GHC.Base.String)[OneShot] ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (SPL.$fShowVar_$cshow @ a $dShow x)
                      s1)
                   ls
                   s) -}
475a314e24adb901a231766e201ad80e
  $fShowVar_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> SPL.Var a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(C(C1(C1(U))),A,A)><L,A><L,U><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x :: SPL.Var a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (SPL.$fShowVar_$cshow @ a $dShow x))
                   s) -}
9c9cda5e3d02a79331ff20d7d8195885
  $tc'Var :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5951828971266103913##
                   12640719403396013995##
                   SPL.$trModule
                   SPL.$tc'Var2
                   1#
                   SPL.$tc'Var1) -}
e83f2ca65d2d9e72bd4441dd75a928f9
  $tc'Var1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4d879d4a718f3d88da4df0d2b6629f96
  $tc'Var2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SPL.$tc'Var3) -}
7bf18027b70c40465c8c85482397f1bb
  $tc'Var3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Var"#) -}
044e3786c619a0f907b80ac48db788ec
  $tcVar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   655598138532826780##
                   12785380069539370572##
                   SPL.$trModule
                   SPL.$tcVar1
                   0#
                   GHC.Types.krep$*Arr*) -}
2ef6e0217b4ee47e323d0a5f03eecd5b
  $tcVar1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SPL.$tcVar2) -}
4553825b4db019be33b4bf28613034b3
  $tcVar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Var"#) -}
635c8c0c1c0cbde0f3e060c8aa515ec8
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module SPL.$trModule3 SPL.$trModule1) -}
fdb498b8457bb0fb028c8fc609038436
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SPL.$trModule2) -}
6d83d8beb97b8a98ee79073fc6cdca15
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SPL"#) -}
5cd6f008d77a507e0a1a0c0d0c37709f
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SPL.$trModule4) -}
15ab45db8dd950ed09111b3dd4124318
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL"#) -}
cf4176ce7f151043880ff4a259cd5a2b
  $wapply_ ::
    (a -> b) -> SPL.PresenceCondition -> SPL.Var a -> SPL.Var b
  {- Arity: 3, Strictness: <L,C(U)><L,U><L,U>, Inline: -}
064386188d9bd2d9dbdc3ff470cd66db
  $wcond' ::
    SPL.Var GHC.Types.Bool -> SPL.Var a -> SPL.Var a -> SPL.Var a
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [2],
     Unfolding: (\ @ a
                   (w :: SPL.Var GHC.Types.Bool)
                   (w1 :: SPL.Var a)
                   (w2 :: SPL.Var a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.cond'} True True} case w `cast`
                                                                                       (SPL.N:Var[0]
                                                                                            <GHC.Types.Bool>_R) of c { DEFAULT ->
                                                                                  SPL.compact
                                                                                    @ a
                                                                                    (let {
                                                                                       parts :: [SPL.Var
                                                                                                   a]
                                                                                       = {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.cond'.parts} True True} GHC.Base.map
                                                                                                                                                                  @ (GHC.Types.Bool,
                                                                                                                                                                     SPL.PresenceCondition)
                                                                                                                                                                  @ (SPL.Var
                                                                                                                                                                       a)
                                                                                                                                                                  (\ (c' :: (GHC.Types.Bool,
                                                                                                                                                                             SPL.PresenceCondition)) ->
                                                                                                                                                                   {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.cond'.parts.\} True True} case c' of wild { (,) ds pc ->
                                                                                                                                                                                                                                            case ds of wild1 {
                                                                                                                                                                                                                                              GHC.Types.False
                                                                                                                                                                                                                                              -> (SPL.cond'2
                                                                                                                                                                                                                                                    @ a
                                                                                                                                                                                                                                                    pc
                                                                                                                                                                                                                                                    w2)
                                                                                                                                                                                                                                                   `cast`
                                                                                                                                                                                                                                                 (Sym (SPL.N:Var[0]
                                                                                                                                                                                                                                                           <a>_R))
                                                                                                                                                                                                                                              GHC.Types.True
                                                                                                                                                                                                                                              -> (SPL.cond'2
                                                                                                                                                                                                                                                    @ a
                                                                                                                                                                                                                                                    pc
                                                                                                                                                                                                                                                    w1)
                                                                                                                                                                                                                                                   `cast`
                                                                                                                                                                                                                                                 (Sym (SPL.N:Var[0]
                                                                                                                                                                                                                                                           <a>_R)) } })
                                                                                                                                                                  c
                                                                                     } in
                                                                                     {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.cond'.agg} True True} SPL.cond'1
                                                                                                                                                            @ a
                                                                                                                                                            parts) }) -}
475a314e24adb901a231766e201ad80e
  $wexists ::
    GHC.Classes.Eq t =>
    t -> SPL.PresenceCondition -> SPL.Var t -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(C(C1(U)),A)><L,U><L,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ t
                   (w :: GHC.Classes.Eq t)
                   (ww :: t)
                   (ww1 :: SPL.PresenceCondition)
                   (w1 :: SPL.Var t) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.exists} True True} letrec {
                                                                                     go :: [(t,
                                                                                             SPL.PresenceCondition)]
                                                                                           -> GHC.Types.Bool
                                                                                       <join 1> {- Arity: 1,
                                                                                                   Strictness: <S,1*U> -}
                                                                                     = \ (ds :: [(t,
                                                                                                  SPL.PresenceCondition)]) ->
                                                                                       case ds of wild {
                                                                                         []
                                                                                         -> GHC.Types.False
                                                                                         : y ys
                                                                                         -> case y of wild1 { (,) y1 ypc ->
                                                                                            case GHC.Classes.==
                                                                                                   @ t
                                                                                                   w
                                                                                                   ww
                                                                                                   y1 of wild2 {
                                                                                              GHC.Types.False
                                                                                              -> go
                                                                                                   ys
                                                                                              GHC.Types.True
                                                                                              -> case PropBDD.implies
                                                                                                        ww1
                                                                                                        ypc of wild3 {
                                                                                                   GHC.Types.False
                                                                                                   -> go
                                                                                                        ys
                                                                                                   GHC.Types.True
                                                                                                   -> GHC.Types.True } } } }
                                                                                   } in
                                                                                   {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.exists.ys} True False} go
                                                                                                                                                           ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.exists.(...)} True True} {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.compactEq} True False} w1)
                                                                                                                                                             `cast`
                                                                                                                                                           (SPL.N:Var[0]
                                                                                                                                                                <t>_R)) -}
14d852f16cfdbcfedff5b948a45e2ec8
  $winv :: SPL.Var t -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ @ t (w :: SPL.Var t) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.inv} True True} SPL.inv2
                                                                                  @ t
                                                                                  ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.pairs} True True} case w `cast`
                                                                                                                                                         (SPL.N:Var[0]
                                                                                                                                                              <t>_R) of wild {
                                                                                                                                                      []
                                                                                                                                                      -> GHC.Types.[]
                                                                                                                                                           @ (SPL.Val
                                                                                                                                                                t,
                                                                                                                                                              SPL.Val
                                                                                                                                                                t)
                                                                                                                                                      : ipv ipv1
                                                                                                                                                      -> GHC.List.zip
                                                                                                                                                           @ (t,
                                                                                                                                                              SPL.PresenceCondition)
                                                                                                                                                           @ (t,
                                                                                                                                                              SPL.PresenceCondition)
                                                                                                                                                           wild
                                                                                                                                                           ipv1 })) -}
c14ff3cf79aac6bcc1188110cc3f33d4
  $wliftA4 ::
    GHC.Base.Functor f =>
    (forall a1 b1. f (a1 -> b1) -> f a1 -> f b1)
    -> (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><C(C(S)),C(C1(U))><L,U><L,U><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ f :: * -> *
                   @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   (ww :: GHC.Base.Functor f)
                   (ww1 :: forall a1 b1. f (a1 -> b1) -> f a1 -> f b1)
                   (w :: a -> b -> c -> d -> e)
                   (w1 :: f a)
                   (w2 :: f b)
                   (w3 :: f c)
                   (w4 :: f d) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftA4} True True} ww1
                                                                                     @ d
                                                                                     @ e
                                                                                     (ww1
                                                                                        @ c
                                                                                        @ (d -> e)
                                                                                        (ww1
                                                                                           @ b
                                                                                           @ (c
                                                                                              -> d
                                                                                              -> e)
                                                                                           (GHC.Base.fmap
                                                                                              @ f
                                                                                              ww
                                                                                              @ a
                                                                                              @ (b
                                                                                                 -> c
                                                                                                 -> d
                                                                                                 -> e)
                                                                                              w
                                                                                              w1)
                                                                                           w2)
                                                                                        w3)
                                                                                     w4) -}
25d8950443607156f6326ad220aacb2d
  $wliftA5 ::
    GHC.Base.Functor f =>
    (forall a1 b1. f (a1 -> b1) -> f a1 -> f b1)
    -> (a -> b -> c -> d -> e -> g)
    -> f a
    -> f b
    -> f c
    -> f d
    -> f e
    -> f g
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><C(C(S)),C(C1(U))><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ f :: * -> *
                   @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ g
                   (ww :: GHC.Base.Functor f)
                   (ww1 :: forall a1 b1. f (a1 -> b1) -> f a1 -> f b1)
                   (w :: a -> b -> c -> d -> e -> g)
                   (w1 :: f a)
                   (w2 :: f b)
                   (w3 :: f c)
                   (w4 :: f d)
                   (w5 :: f e) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftA5} True True} ww1
                                                                                     @ e
                                                                                     @ g
                                                                                     (ww1
                                                                                        @ d
                                                                                        @ (e -> g)
                                                                                        (ww1
                                                                                           @ c
                                                                                           @ (d
                                                                                              -> e
                                                                                              -> g)
                                                                                           (ww1
                                                                                              @ b
                                                                                              @ (c
                                                                                                 -> d
                                                                                                 -> e
                                                                                                 -> g)
                                                                                              (GHC.Base.fmap
                                                                                                 @ f
                                                                                                 ww
                                                                                                 @ a
                                                                                                 @ (b
                                                                                                    -> c
                                                                                                    -> d
                                                                                                    -> e
                                                                                                    -> g)
                                                                                                 w
                                                                                                 w1)
                                                                                              w2)
                                                                                           w3)
                                                                                        w4)
                                                                                     w5) -}
40b726ee7a7773a4d94dbfe75b449bef
  (===) :: a -> a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a (x :: a) (y :: a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.===} True True} case x of x1 { DEFAULT ->
                                                                                case y of y1 { DEFAULT ->
                                                                                case GHC.Magic.runRW#
                                                                                       @ ('GHC.Types.TupleRep
                                                                                            '[ 'GHC.Types.TupleRep
                                                                                                 '[],
                                                                                               'GHC.Types.LiftedRep])
                                                                                       @ (# GHC.Prim.State#
                                                                                              GHC.Prim.RealWorld,
                                                                                            GHC.Types.Bool #)
                                                                                       (\ (s :: GHC.Prim.State#
                                                                                                  GHC.Prim.RealWorld)[OneShot] ->
                                                                                        case GHC.Prim.noDuplicate#
                                                                                               @ GHC.Prim.RealWorld
                                                                                               s of s' { DEFAULT ->
                                                                                        case GHC.Prim.makeStableName#
                                                                                               @ a
                                                                                               x1
                                                                                               s' of ds { (#,#) ipv ipv1 ->
                                                                                        case GHC.Prim.makeStableName#
                                                                                               @ a
                                                                                               y1
                                                                                               ipv of ds1 { (#,#) ipv2 ipv3 ->
                                                                                        (# ipv2,
                                                                                           case GHC.Prim.eqStableName#
                                                                                                  @ a
                                                                                                  @ a
                                                                                                  ipv1
                                                                                                  ipv3 of ds2 {
                                                                                             DEFAULT
                                                                                             -> GHC.Types.True
                                                                                             0#
                                                                                             -> GHC.Types.False } #) } } }) of ds { (#,#) ipv ipv1 ->
                                                                                ipv1 } } }) -}
9d82468f96bff93fd3a1ccb2e50cee47
  (====) :: GHC.Classes.Eq a => a -> a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (x :: a) (y :: a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.====} True True} case SPL.===
                                                                                        @ a
                                                                                        x
                                                                                        y of wild {
                                                                                   GHC.Types.False
                                                                                   -> GHC.Classes.==
                                                                                        @ a
                                                                                        $dEq
                                                                                        x
                                                                                        y
                                                                                   GHC.Types.True
                                                                                   -> GHC.Types.True }) -}
9890cb4767809714c90fa1d6c940f978
  type PresenceCondition = PropBDD.Prop
a64aab41b1e6ab8eec7b80bce277b123
  type Val a = (a, SPL.PresenceCondition)
475a314e24adb901a231766e201ad80e
  newtype Var t = Var [SPL.Val t]
475a314e24adb901a231766e201ad80e
  apply :: SPL.Var (a -> b) -> SPL.Var a -> SPL.Var b
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: -}
bfdd3263763fec92478d65748e377520
  apply_ :: SPL.Val (a -> b) -> SPL.Var a -> SPL.Var b
  {- Arity: 2, Strictness: <S,1*U(C(U),U)><L,U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: SPL.Val (a -> b)) (w1 :: SPL.Var a) ->
                 case w of ww { (,) ww1 ww2 -> SPL.$wapply_ @ a @ b ww1 ww2 w1 }) -}
475a314e24adb901a231766e201ad80e
  compact :: SPL.Var t -> SPL.Var t
  {- Unfolding: (\ @ t ->
                 ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.compact} True False} GHC.Base.id)
                   @ (SPL.Var t)) -}
a930e705034943f3770db9faeb9b7921
  compactEq :: GHC.Classes.Eq t => SPL.Var t -> SPL.Var t
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t ($dEq :: GHC.Classes.Eq t) -> SPL.compactEq1 @ t) -}
871a079ad67bc8af54a953260608aa69
  compactEq1 :: SPL.Var t -> SPL.Var t
  {- Unfolding: (\ @ t ->
                 ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.compactEq} True False} GHC.Base.id)
                   @ (SPL.Var t)) -}
b301b12ff6a351f8906157d2e14a8571
  cond :: GHC.Types.Bool -> a -> a -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a (p :: GHC.Types.Bool) (a1 :: a) (b :: a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.cond} True True} case p of wild {
                                                                                   GHC.Types.False
                                                                                   -> b
                                                                                   GHC.Types.True
                                                                                   -> a1 }) -}
52391d2437128a772a0268974784df0f
  cond' ::
    GHC.Show.Show a =>
    SPL.Var GHC.Types.Bool -> SPL.Var a -> SPL.Var a -> SPL.Var a
  {- Arity: 4, Strictness: <L,A><S,1*U><L,U><L,U>, Inline: [2],
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: SPL.Var GHC.Types.Bool)
                   (w2 :: SPL.Var a)
                   (w3 :: SPL.Var a) ->
                 SPL.$wcond' @ a w1 w2 w3) -}
a65860a9549a4498b25f6c0043a67902
  cond'1 :: [SPL.Var a] -> SPL.Var a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
fa3b113a47ccab1785bafd2abf026523
  cond'2 :: SPL.PresenceCondition -> SPL.Var t -> [(t, PropBDD.Prop)]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ t
                   (pc :: SPL.PresenceCondition)
                   (ds :: SPL.Var t) ->
                 let {
                   lvl :: [PropBDD.Prop]
                   = GHC.Types.: @ PropBDD.Prop pc (GHC.Types.[] @ PropBDD.Prop)
                 } in
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.restrict} True True} letrec {
                                                                                       go :: [(t,
                                                                                               PropBDD.Prop)]
                                                                                             -> [(t,
                                                                                                  PropBDD.Prop)]
                                                                                         {- Arity: 1,
                                                                                            Strictness: <S,1*U> -}
                                                                                       = \ (ds1 :: [(t,
                                                                                                     PropBDD.Prop)]) ->
                                                                                         case ds1 of wild {
                                                                                           []
                                                                                           -> GHC.Types.[]
                                                                                                @ (t,
                                                                                                   PropBDD.Prop)
                                                                                           : y ys
                                                                                           -> case y of wild1 { (,) x pc' ->
                                                                                              let {
                                                                                                pc'1 :: PropBDD.Prop
                                                                                                = {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.restrict.\} False True} PropBDD.conj
                                                                                                                                                                           (GHC.Types.:
                                                                                                                                                                              @ PropBDD.Prop
                                                                                                                                                                              pc'
                                                                                                                                                                              lvl)
                                                                                              } in
                                                                                              {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.restrict.\} True False} case {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.restrict.\} True True} PropBDD.sat
                                                                                                                                                                                                                                                  pc'1 of wild2 {
                                                                                                                                                                       GHC.Types.False
                                                                                                                                                                       -> go
                                                                                                                                                                            ys
                                                                                                                                                                       GHC.Types.True
                                                                                                                                                                       -> GHC.Types.:
                                                                                                                                                                            @ (t,
                                                                                                                                                                               PropBDD.Prop)
                                                                                                                                                                            (x,
                                                                                                                                                                             pc'1)
                                                                                                                                                                            (go
                                                                                                                                                                               ys) } } }
                                                                                     } in
                                                                                     go
                                                                                       ds
                                                                                         `cast`
                                                                                       (SPL.N:Var[0]
                                                                                            <t>_R)) -}
4f6379495b00425b2413e0f8bf19b8b3
  definedAt :: SPL.Var t -> SPL.PresenceCondition
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: SPL.Var t) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.definedAt} True True} PropBDD.disj
                                                                                        ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.definedAt.pcs} True True} GHC.Base.build
                                                                                                                                                                    @ Cudd.Cudd.DDNode
                                                                                                                                                                    (\ @ b1
                                                                                                                                                                       (c :: Cudd.Cudd.DDNode
                                                                                                                                                                             -> b1
                                                                                                                                                                             -> b1)[OneShot]
                                                                                                                                                                       (n :: b1)[OneShot] ->
                                                                                                                                                                     GHC.Base.foldr
                                                                                                                                                                       @ (t,
                                                                                                                                                                          SPL.PresenceCondition)
                                                                                                                                                                       @ b1
                                                                                                                                                                       (GHC.Base.mapFB
                                                                                                                                                                          @ Cudd.Cudd.DDNode
                                                                                                                                                                          @ b1
                                                                                                                                                                          @ (t,
                                                                                                                                                                             SPL.PresenceCondition)
                                                                                                                                                                          c
                                                                                                                                                                          (Data.Tuple.snd
                                                                                                                                                                             @ t
                                                                                                                                                                             @ SPL.PresenceCondition))
                                                                                                                                                                       n
                                                                                                                                                                       ds
                                                                                                                                                                         `cast`
                                                                                                                                                                       (SPL.N:Var[0]
                                                                                                                                                                            <t>_R)))) -}
475a314e24adb901a231766e201ad80e
  exists ::
    GHC.Classes.Eq t => SPL.Val t -> SPL.Var t -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,1*U(U,U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   (w :: GHC.Classes.Eq t)
                   (w1 :: SPL.Val t)
                   (w2 :: SPL.Var t) ->
                 case w1 of ww { (,) ww1 ww2 -> SPL.$wexists @ t w ww1 ww2 w2 }) -}
8ccbe94f16a728a2e0d785a75b803aca
  filterLifted ::
    SPL.Var (a -> GHC.Types.Bool) -> SPL.Var [a] -> SPL.Var [a]
  {- Unfolding: (\ @ a ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.filterLifted} True False} \ (x :: SPL.Var
                                                                                                    (a
                                                                                                     -> GHC.Types.Bool)) ->
                                                                                          {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.filterLifted} False True} SPL.$fApplicativeVar_$c<*>
                                                                                                                                                                     @ [a]
                                                                                                                                                                     @ [a]
                                                                                                                                                                     (({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                                                                                                                                                                         @ (a
                                                                                                                                                                                                                                            -> GHC.Types.Bool)
                                                                                                                                                                                                                                         @ ([a]
                                                                                                                                                                                                                                            -> [a])
                                                                                                                                                                                                                                         (SPL.filterLifted1
                                                                                                                                                                                                                                            @ a)
                                                                                                                                                                                                                                           `cast`
                                                                                                                                                                                                                                         (Sym (SPL.N:Var[0]
                                                                                                                                                                                                                                                   <(a
                                                                                                                                                                                                                                                     -> GHC.Types.Bool)
                                                                                                                                                                                                                                                    -> [a]
                                                                                                                                                                                                                                                    -> [a]>_R)))
                                                                                                                                                                        x)) -}
13895e5a43133f42416b0a524f9fd8f1
  filterLifted1 :: [SPL.Val ((a -> GHC.Types.Bool) -> [a] -> [a])]
  {- Strictness: m2,
     Unfolding: (\ @ a ->
                 GHC.Types.:
                   @ (SPL.Val ((a -> GHC.Types.Bool) -> [a] -> [a]))
                   (SPL.filterLifted2 @ a)
                   (GHC.Types.[]
                      @ (SPL.Val ((a -> GHC.Types.Bool) -> [a] -> [a])))) -}
f6394a18fbe28f688b112cc5ca234363
  filterLifted2 ::
    ((a -> GHC.Types.Bool) -> [a] -> [a], SPL.PresenceCondition)
  {- Strictness: m,
     Unfolding: (\ @ a -> (GHC.List.filter @ a, PropBDD.tt)) -}
b999feaf07f408ab4791f1855ddeb7ef
  findVal ::
    t -> [SPL.Val t] -> (t -> t -> GHC.Types.Bool) -> [SPL.Val t]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,C(C1(U))> -}
f2d0b3542c06d9056462a8a34e7ab38d
  getAllConfigs :: [PropBDD.Prop] -> [PropBDD.Prop]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [PropBDD.Prop]) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getAllConfigs} True True} case ds of wild {
                                                                                            []
                                                                                            -> GHC.Types.[]
                                                                                                 @ PropBDD.Prop
                                                                                            : f ds1
                                                                                            -> case ds1 of wild1 {
                                                                                                 []
                                                                                                 -> GHC.Types.:
                                                                                                      @ PropBDD.Prop
                                                                                                      f
                                                                                                      (GHC.Types.:
                                                                                                         @ PropBDD.Prop
                                                                                                         (PropBDD.impl1
                                                                                                            f)
                                                                                                           `cast`
                                                                                                         (Sym (Cudd.Cudd.N:DDNode[0]))
                                                                                                         (GHC.Types.[]
                                                                                                            @ PropBDD.Prop))
                                                                                                 : ipv ipv1
                                                                                                 -> let {
                                                                                                      rest :: [PropBDD.Prop]
                                                                                                      = {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getAllConfigs.rest} True True} SPL.getAllConfigs_$sgetAllConfigs
                                                                                                                                                                                        ipv
                                                                                                                                                                                        ipv1
                                                                                                    } in
                                                                                                    GHC.Base.++
                                                                                                      @ Cudd.Cudd.DDNode
                                                                                                      ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getAllConfigs.fPos} True True} GHC.Base.map
                                                                                                                                                                                       @ Cudd.Cudd.DDNode
                                                                                                                                                                                       @ Cudd.Cudd.DDNode
                                                                                                                                                                                       (\ (r :: PropBDD.Prop) ->
                                                                                                                                                                                        {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getAllConfigs.fPos.\} True True} PropBDD.conj
                                                                                                                                                                                                                                                                          (GHC.Types.:
                                                                                                                                                                                                                                                                             @ PropBDD.Prop
                                                                                                                                                                                                                                                                             f
                                                                                                                                                                                                                                                                             (GHC.Types.:
                                                                                                                                                                                                                                                                                @ PropBDD.Prop
                                                                                                                                                                                                                                                                                r
                                                                                                                                                                                                                                                                                (GHC.Types.[]
                                                                                                                                                                                                                                                                                   @ PropBDD.Prop))))
                                                                                                                                                                                       rest)
                                                                                                      (let {
                                                                                                         lvl :: GHC.ForeignPtr.ForeignPtr
                                                                                                                  Cudd.C.CDDNode
                                                                                                         = {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getAllConfigs.fNeg} False True} {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getAllConfigs.fNeg.\} False True} PropBDD.impl1
                                                                                                                                                                                                                                                                             f
                                                                                                       } in
                                                                                                       {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getAllConfigs.fNeg} True True} GHC.Base.map
                                                                                                                                                                                       @ Cudd.Cudd.DDNode
                                                                                                                                                                                       @ Cudd.Cudd.DDNode
                                                                                                                                                                                       (\ (r :: PropBDD.Prop) ->
                                                                                                                                                                                        {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getAllConfigs.fNeg.\} True True} PropBDD.conj
                                                                                                                                                                                                                                                                          (GHC.Types.:
                                                                                                                                                                                                                                                                             @ PropBDD.Prop
                                                                                                                                                                                                                                                                             lvl
                                                                                                                                                                                                                                                                               `cast`
                                                                                                                                                                                                                                                                             (Sym (Cudd.Cudd.N:DDNode[0]))
                                                                                                                                                                                                                                                                             (GHC.Types.:
                                                                                                                                                                                                                                                                                @ PropBDD.Prop
                                                                                                                                                                                                                                                                                r
                                                                                                                                                                                                                                                                                (GHC.Types.[]
                                                                                                                                                                                                                                                                                   @ PropBDD.Prop))))
                                                                                                                                                                                       rest) } }) -}
bd8fd2a61c96519783cad679b8db9401
  getAllConfigs_$sgetAllConfigs ::
    Cudd.Cudd.DDNode -> [Cudd.Cudd.DDNode] -> [PropBDD.Prop]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
10d6d26f576e18d312c60e75097b5f42
  getValidConfigs ::
    [PropBDD.Prop] -> SPL.PresenceCondition -> [PropBDD.Prop]
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (univ :: [PropBDD.Prop])
                   (featModel :: SPL.PresenceCondition) ->
                 let {
                   lvl :: [PropBDD.Prop]
                   = GHC.Types.:
                       @ PropBDD.Prop
                       featModel
                       (GHC.Types.[] @ PropBDD.Prop)
                 } in
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getValidConfigs} True True} GHC.List.filter
                                                                                              @ Cudd.Cudd.DDNode
                                                                                              (\ (c :: PropBDD.Prop) ->
                                                                                               {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getValidConfigs.\} True True} let {
                                                                                                                                                                              p :: PropBDD.Prop
                                                                                                                                                                              = PropBDD.conj
                                                                                                                                                                                  (GHC.Types.:
                                                                                                                                                                                     @ PropBDD.Prop
                                                                                                                                                                                     c
                                                                                                                                                                                     lvl)
                                                                                                                                                                            } in
                                                                                                                                                                            {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:PropBDD.sat} True True} Cudd.Cudd.$fEqDDNode1
                                                                                                                                                                                                                                                 p `cast`
                                                                                                                                                                                                                                                 (Cudd.Cudd.N:DDNode[0])
                                                                                                                                                                                                                                                 PropBDD.disj1)
                                                                                              ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.getValidConfigs.cs} True True} SPL.getAllConfigs
                                                                                                                                                                               univ)) -}
2a4a47c176d050cbd28db815e59c87e6
  groupVals ::
    [SPL.Val t] -> (t -> t -> GHC.Types.Bool) -> [SPL.Val t]
  {- Arity: 2, Strictness: <S,1*U><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ t (xs :: [SPL.Val t]) (cmp :: t -> t -> GHC.Types.Bool) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.groupVals} True True} SPL.groupVals_
                                                                                        @ t
                                                                                        xs
                                                                                        (GHC.Types.[]
                                                                                           @ t)
                                                                                        cmp) -}
fa7c616aa8f45e41bd6a00852bc533b4
  groupVals_ ::
    [SPL.Val t] -> [t] -> (t -> t -> GHC.Types.Bool) -> [SPL.Val t]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,C(C1(U))> -}
a0334a2755f7bead30096d8448e0bbcd
  index :: SPL.Var t -> SPL.PresenceCondition -> [t]
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ @ t
                   (ds :: SPL.Var t)
                   (pc :: SPL.PresenceCondition) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.index} True True} case SPL.index1
                                                                                         @ t
                                                                                         ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.index.v'} True True} GHC.List.filter
                                                                                                                                                                @ (t,
                                                                                                                                                                   PropBDD.Prop)
                                                                                                                                                                (\ (ds1 :: (t,
                                                                                                                                                                            PropBDD.Prop)) ->
                                                                                                                                                                 case ds1 of wild { (,) x' pc' ->
                                                                                                                                                                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.index.v'.\} True True} let {
                                                                                                                                                                                                                                         p :: PropBDD.Prop
                                                                                                                                                                                                                                         = PropBDD.conj
                                                                                                                                                                                                                                             (GHC.Types.:
                                                                                                                                                                                                                                                @ PropBDD.Prop
                                                                                                                                                                                                                                                pc
                                                                                                                                                                                                                                                (GHC.Types.:
                                                                                                                                                                                                                                                   @ PropBDD.Prop
                                                                                                                                                                                                                                                   pc'
                                                                                                                                                                                                                                                   (GHC.Types.[]
                                                                                                                                                                                                                                                      @ PropBDD.Prop)))
                                                                                                                                                                                                                                       } in
                                                                                                                                                                                                                                       {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:PropBDD.sat} True True} Cudd.Cudd.$fEqDDNode1
                                                                                                                                                                                                                                                                                                            p `cast`
                                                                                                                                                                                                                                                                                                            (Cudd.Cudd.N:DDNode[0])
                                                                                                                                                                                                                                                                                                            PropBDD.disj1 })
                                                                                                                                                                ds
                                                                                                                                                                  `cast`
                                                                                                                                                                (SPL.N:Var[0]
                                                                                                                                                                     <t>_R)) of ww { (#,#) ww1 ww2 ->
                                                                                  ww1 }) -}
905614b3a653d14b65f26be362eb3ad8
  index1 ::
    [(t, SPL.PresenceCondition)] -> (# [t], [SPL.PresenceCondition] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
7ceb690bee41c4a1b5ca62f30063c075
  inv :: GHC.Show.Show t => SPL.Var t -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SPL.inv1
                  `cast`
                (forall (t :: <*>_N).
                 <GHC.Show.Show t>_R
                 ->_R <SPL.Var t>_R
                 ->_R Data.Semigroup.Internal.N:All[0]) -}
2353502732bd07f6fddb3624ba64e7af
  inv1 :: GHC.Show.Show t => SPL.Var t -> Data.Semigroup.Internal.All
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: [2],
     Unfolding: InlineRule (2, True, True)
                (\ @ t (w :: GHC.Show.Show t) (w1 :: SPL.Var t) ->
                 SPL.$winv @ t w1) -}
6e53c6049ab41b95c8f82544a9d2926c
  inv2 ::
    [((t, PropBDD.Prop), (t, PropBDD.Prop))]
    -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,1*U> -}
02672838bd1b1d8f4440b6d73f10e712
  isSubsetOf ::
    GHC.Classes.Eq t => SPL.Var t -> SPL.Var t -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                SPL.$fEqVar1
                  `cast`
                (forall (t :: <*>_N).
                 <GHC.Classes.Eq t>_R
                 ->_R <SPL.Var t>_R
                 ->_R <SPL.Var t>_R
                 ->_R Data.Semigroup.Internal.N:All[0]) -}
cd0d98c3237d3bebafdade18ab782851
  liftA4 ::
    GHC.Base.Applicative f =>
    (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLL),1*U(1*U(1*C1(C1(U)),A),A,C(C1(U)),A,A,A)><L,U><L,U><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: InlineRule (6, True, False)
                (\ @ f :: * -> *
                   @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> b -> c -> d -> e)
                   (w2 :: f a)
                   (w3 :: f b)
                   (w4 :: f c)
                   (w5 :: f d) ->
                 case w of ww { GHC.Base.C:Applicative ww1 ww2 ww3 ww4 ww5 ww6 ->
                 SPL.$wliftA4 @ f @ a @ b @ c @ d @ e ww1 ww3 w1 w2 w3 w4 w5 }) -}
10e4769b1991f9ad608c385ced91c033
  liftA5 ::
    GHC.Base.Applicative f =>
    (a -> b -> c -> d -> e -> g)
    -> f a -> f b -> f c -> f d -> f e -> f g
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLL),1*U(1*U(1*C1(C1(U)),A),A,C(C1(U)),A,A,A)><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ @ f :: * -> *
                   @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ g
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> b -> c -> d -> e -> g)
                   (w2 :: f a)
                   (w3 :: f b)
                   (w4 :: f c)
                   (w5 :: f d)
                   (w6 :: f e) ->
                 case w of ww { GHC.Base.C:Applicative ww1 ww2 ww3 ww4 ww5 ww6 ->
                 SPL.$wliftA5
                   @ f
                   @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ g
                   ww1
                   ww3
                   w1
                   w2
                   w3
                   w4
                   w5
                   w6 }) -}
c910a1a011d076facadbf03954925c4f
  liftV :: (a -> b) -> SPL.Var a -> SPL.Var b
  {- Unfolding: (\ @ a @ b ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV} True False} \ (f1 :: a
                                                                                            -> b)
                                                                                     (a1 :: SPL.Var
                                                                                              a) ->
                                                                                   {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV} False True} SPL.$fApplicativeVar_$c<*>
                                                                                                                                                       @ a
                                                                                                                                                       @ b
                                                                                                                                                       (SPL.$fApplicativeVar_$cpure
                                                                                                                                                          @ (a
                                                                                                                                                             -> b)
                                                                                                                                                          f1)
                                                                                                                                                       a1) -}
6eb80ae5602cd6b28fa33cd634e05af9
  liftV2 :: (a -> b -> c) -> SPL.Var a -> SPL.Var b -> SPL.Var c
  {- Unfolding: ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV2} True False} SPL.$fApplicativeVar_$cliftA2) -}
42f461e113c617a87f9a7c2a4bb56700
  liftV3 ::
    (a -> b -> c -> d)
    -> SPL.Var a -> SPL.Var b -> SPL.Var c -> SPL.Var d
  {- Unfolding: (\ @ a @ b @ c @ d ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV3} True False} \ (f1 :: a
                                                                                             -> b
                                                                                             -> c
                                                                                             -> d)
                                                                                      (a1 :: SPL.Var
                                                                                               a)
                                                                                      (b1 :: SPL.Var
                                                                                               b)
                                                                                      (c1 :: SPL.Var
                                                                                               c) ->
                                                                                    {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV3} False True} SPL.$fApplicativeVar_$c<*>
                                                                                                                                                         @ c
                                                                                                                                                         @ d
                                                                                                                                                         (SPL.$fApplicativeVar_$c<*>
                                                                                                                                                            @ b
                                                                                                                                                            @ (c
                                                                                                                                                               -> d)
                                                                                                                                                            (({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                                                                                                                                                                @ a
                                                                                                                                                                                                                                @ (b
                                                                                                                                                                                                                                   -> c
                                                                                                                                                                                                                                   -> d)
                                                                                                                                                                                                                                (SPL.mkVarT
                                                                                                                                                                                                                                   @ (a
                                                                                                                                                                                                                                      -> b
                                                                                                                                                                                                                                      -> c
                                                                                                                                                                                                                                      -> d)
                                                                                                                                                                                                                                   f1))
                                                                                                                                                               a1)
                                                                                                                                                            b1)
                                                                                                                                                         c1) -}
8768948bf430d974ae33217d8668bbaa
  liftV4 ::
    (a -> b -> c -> d -> e)
    -> SPL.Var a -> SPL.Var b -> SPL.Var c -> SPL.Var d -> SPL.Var e
  {- Unfolding: (\ @ a @ b @ c @ d @ e ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV4} True False} \ (eta :: a
                                                                                              -> b
                                                                                              -> c
                                                                                              -> d
                                                                                              -> e)
                                                                                      (eta1 :: SPL.Var
                                                                                                 a)
                                                                                      (eta2 :: SPL.Var
                                                                                                 b)
                                                                                      (eta3 :: SPL.Var
                                                                                                 c)
                                                                                      (eta4 :: SPL.Var
                                                                                                 d) ->
                                                                                    {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV4} False True} {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftA4} True True} SPL.$fApplicativeVar_$c<*>
                                                                                                                                                                                                                           @ d
                                                                                                                                                                                                                           @ e
                                                                                                                                                                                                                           (SPL.$fApplicativeVar_$c<*>
                                                                                                                                                                                                                              @ c
                                                                                                                                                                                                                              @ (d
                                                                                                                                                                                                                                 -> e)
                                                                                                                                                                                                                              (SPL.$fApplicativeVar_$c<*>
                                                                                                                                                                                                                                 @ b
                                                                                                                                                                                                                                 @ (c
                                                                                                                                                                                                                                    -> d
                                                                                                                                                                                                                                    -> e)
                                                                                                                                                                                                                                 (({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                                                                                                                                                                                                                                     @ a
                                                                                                                                                                                                                                                                                                     @ (b
                                                                                                                                                                                                                                                                                                        -> c
                                                                                                                                                                                                                                                                                                        -> d
                                                                                                                                                                                                                                                                                                        -> e)
                                                                                                                                                                                                                                                                                                     (SPL.mkVarT
                                                                                                                                                                                                                                                                                                        @ (a
                                                                                                                                                                                                                                                                                                           -> b
                                                                                                                                                                                                                                                                                                           -> c
                                                                                                                                                                                                                                                                                                           -> d
                                                                                                                                                                                                                                                                                                           -> e)
                                                                                                                                                                                                                                                                                                        eta))
                                                                                                                                                                                                                                    eta1)
                                                                                                                                                                                                                                 eta2)
                                                                                                                                                                                                                              eta3)
                                                                                                                                                                                                                           eta4) -}
78247f293fce09ea83e9aeb3e4692793
  liftV5 ::
    (a -> b -> c -> d -> e -> f)
    -> SPL.Var a
    -> SPL.Var b
    -> SPL.Var c
    -> SPL.Var d
    -> SPL.Var e
    -> SPL.Var f
  {- Unfolding: (\ @ a @ b @ c @ d @ e @ f ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV5} True False} \ (eta :: a
                                                                                              -> b
                                                                                              -> c
                                                                                              -> d
                                                                                              -> e
                                                                                              -> f)
                                                                                      (eta1 :: SPL.Var
                                                                                                 a)
                                                                                      (eta2 :: SPL.Var
                                                                                                 b)
                                                                                      (eta3 :: SPL.Var
                                                                                                 c)
                                                                                      (eta4 :: SPL.Var
                                                                                                 d)
                                                                                      (eta5 :: SPL.Var
                                                                                                 e) ->
                                                                                    {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftV5} False True} {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.liftA5} True True} SPL.$fApplicativeVar_$c<*>
                                                                                                                                                                                                                           @ e
                                                                                                                                                                                                                           @ f
                                                                                                                                                                                                                           (SPL.$fApplicativeVar_$c<*>
                                                                                                                                                                                                                              @ d
                                                                                                                                                                                                                              @ (e
                                                                                                                                                                                                                                 -> f)
                                                                                                                                                                                                                              (SPL.$fApplicativeVar_$c<*>
                                                                                                                                                                                                                                 @ c
                                                                                                                                                                                                                                 @ (d
                                                                                                                                                                                                                                    -> e
                                                                                                                                                                                                                                    -> f)
                                                                                                                                                                                                                                 (SPL.$fApplicativeVar_$c<*>
                                                                                                                                                                                                                                    @ b
                                                                                                                                                                                                                                    @ (c
                                                                                                                                                                                                                                       -> d
                                                                                                                                                                                                                                       -> e
                                                                                                                                                                                                                                       -> f)
                                                                                                                                                                                                                                    (({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                                                                                                                                                                                                                                        @ a
                                                                                                                                                                                                                                                                                                        @ (b
                                                                                                                                                                                                                                                                                                           -> c
                                                                                                                                                                                                                                                                                                           -> d
                                                                                                                                                                                                                                                                                                           -> e
                                                                                                                                                                                                                                                                                                           -> f)
                                                                                                                                                                                                                                                                                                        (SPL.mkVarT
                                                                                                                                                                                                                                                                                                           @ (a
                                                                                                                                                                                                                                                                                                              -> b
                                                                                                                                                                                                                                                                                                              -> c
                                                                                                                                                                                                                                                                                                              -> d
                                                                                                                                                                                                                                                                                                              -> e
                                                                                                                                                                                                                                                                                                              -> f)
                                                                                                                                                                                                                                                                                                           eta))
                                                                                                                                                                                                                                       eta1)
                                                                                                                                                                                                                                    eta2)
                                                                                                                                                                                                                                 eta3)
                                                                                                                                                                                                                              eta4)
                                                                                                                                                                                                                           eta5) -}
2d14bfa533ee30ca529d2e5b0597ded5
  mapLifted :: SPL.Var (a -> b) -> SPL.Var [a] -> SPL.Var [b]
  {- Unfolding: (\ @ a @ b ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.mapLifted} True False} \ (x :: SPL.Var
                                                                                                 (a
                                                                                                  -> b)) ->
                                                                                       {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.mapLifted} False True} SPL.$fApplicativeVar_$c<*>
                                                                                                                                                               @ [a]
                                                                                                                                                               @ [b]
                                                                                                                                                               (({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.fmap} True True} SPL.apply
                                                                                                                                                                                                                                   @ (a
                                                                                                                                                                                                                                      -> b)
                                                                                                                                                                                                                                   @ ([a]
                                                                                                                                                                                                                                      -> [b])
                                                                                                                                                                                                                                   (SPL.mapLifted1
                                                                                                                                                                                                                                      @ a
                                                                                                                                                                                                                                      @ b)
                                                                                                                                                                                                                                     `cast`
                                                                                                                                                                                                                                   (Sym (SPL.N:Var[0]
                                                                                                                                                                                                                                             <(a
                                                                                                                                                                                                                                               -> b)
                                                                                                                                                                                                                                              -> [a]
                                                                                                                                                                                                                                              -> [b]>_R)))
                                                                                                                                                                  x)) -}
e042bdf799ba2fd0c0baecebbf5ff536
  mapLifted1 :: [SPL.Val ((a -> b) -> [a] -> [b])]
  {- Strictness: m2,
     Unfolding: (\ @ a @ b ->
                 GHC.Types.:
                   @ (SPL.Val ((a -> b) -> [a] -> [b]))
                   (SPL.mapLifted2 @ b @ a)
                   (GHC.Types.[] @ (SPL.Val ((a -> b) -> [a] -> [b])))) -}
6f105bc440ce8fd56ae307d5cd4ad6ea
  mapLifted2 :: ((a -> b) -> [a] -> [b], SPL.PresenceCondition)
  {- Strictness: m,
     Unfolding: (\ @ b @ a -> (GHC.Base.map @ a @ b, PropBDD.tt)) -}
475a314e24adb901a231766e201ad80e
  mkVar :: t -> SPL.PresenceCondition -> SPL.Var t
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ t (v :: t) (pc :: SPL.PresenceCondition) ->
                 GHC.Base.build
                   @ (SPL.Val t)
                   (\ @ a (c :: SPL.Val t -> a -> a)[OneShot] (n :: a)[OneShot] ->
                    c (v, pc) n))
                  `cast`
                (forall (t :: <*>_N).
                 <t>_R
                 ->_R <SPL.PresenceCondition>_R
                 ->_R Sym (SPL.N:Var[0] <t>_R)) -}
475a314e24adb901a231766e201ad80e
  mkVarT :: t -> SPL.Var t
  {- Arity: 1, Strictness: <L,U>m2, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ t (v :: t) -> SPL.mkVar @ t v PropBDD.tt) -}
025cc7ad79f74769a76ef7e9162bca4d
  mkVars :: [(t, SPL.PresenceCondition)] -> SPL.Var t
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SPL.mkVars1
                  `cast`
                (forall (t :: <*>_N).
                 <[(t, SPL.PresenceCondition)]>_R ->_R Sym (SPL.N:Var[0] <t>_R)) -}
1cd26767fb27472240c9750e082d546a
  mkVars1 ::
    [(t, SPL.PresenceCondition)] -> [(t, SPL.PresenceCondition)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t (vs :: [(t, SPL.PresenceCondition)]) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.mkVars} True False} vs) -}
20b811d5c4fd8c6013ce149d67a97cee
  pairs :: [t] -> [(t, t)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: [t]) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.pairs} True True} case ds of wild {
                                                                                    []
                                                                                    -> GHC.Types.[]
                                                                                         @ (t, t)
                                                                                    : ipv ipv1
                                                                                    -> GHC.Base.build
                                                                                         @ (t, t)
                                                                                         (\ @ b1
                                                                                            (c :: (t,
                                                                                                   t)
                                                                                                  -> b1
                                                                                                  -> b1)[OneShot]
                                                                                            (n :: b1)[OneShot] ->
                                                                                          GHC.List.foldr2
                                                                                            @ t
                                                                                            @ t
                                                                                            @ b1
                                                                                            (GHC.List.zipFB
                                                                                               @ t
                                                                                               @ t
                                                                                               @ b1
                                                                                               @ b1
                                                                                               c)
                                                                                            n
                                                                                            wild
                                                                                            ipv1) }) -}
9ab9f6dd99990039bb94a24858af8225
  phelem :: t -> [t] -> (t -> t -> GHC.Types.Bool) -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,C(C1(U))>,
     Unfolding: InlineRule (0, True, True)
                SPL.phelem1
                  `cast`
                (forall (t :: <*>_N).
                 <t>_R
                 ->_R <[t]>_R
                 ->_R <t -> t -> GHC.Types.Bool>_R
                 ->_R Data.Semigroup.Internal.N:Any[0]) -}
2f3ca98c0c602a9318f9ee4a4473c441
  phelem1 ::
    t
    -> [t] -> (t -> t -> GHC.Types.Bool) -> Data.Semigroup.Internal.Any
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,C(C1(U))>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t (v :: t) (xs :: [t]) (cmp :: t -> t -> GHC.Types.Bool) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.phelem} True True} letrec {
                                                                                     go :: [t]
                                                                                           -> Data.Semigroup.Internal.Any
                                                                                       <join 1> {- Arity: 1 -}
                                                                                     = \ (ds :: [t]) ->
                                                                                       case ds of wild {
                                                                                         []
                                                                                         -> GHC.Types.False
                                                                                              `cast`
                                                                                            (Sym (Data.Semigroup.Internal.N:Any[0]))
                                                                                         : y ys
                                                                                         -> case {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.phelem.\} True True} cmp
                                                                                                                                                                       v
                                                                                                                                                                       y of wild1 {
                                                                                              GHC.Types.False
                                                                                              -> go
                                                                                                   ys
                                                                                              GHC.Types.True
                                                                                              -> GHC.Types.True
                                                                                                   `cast`
                                                                                                 (Sym (Data.Semigroup.Internal.N:Any[0])) } }
                                                                                   } in
                                                                                   go xs) -}
850b00edb49c76f195aff76f6e177550
  restrict :: SPL.PresenceCondition -> SPL.Var t -> SPL.Var t
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SPL.cond'2
                  `cast`
                (forall (t :: <*>_N).
                 <SPL.PresenceCondition>_R
                 ->_R <SPL.Var t>_R
                 ->_R Sym (SPL.N:Var[0] <t>_R)) -}
eac634142178a4e2e52905bc9229b782
  subst :: SPL.Var t -> SPL.PresenceCondition -> SPL.Var t
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                SPL.subst1
                  `cast`
                (forall (t :: <*>_N).
                 <SPL.Var t>_R
                 ->_R <SPL.PresenceCondition>_R
                 ->_R Sym (SPL.N:Var[0] <t>_R)) -}
70754f416716b97fb9c065a38e1d8322
  subst1 :: SPL.Var t -> SPL.PresenceCondition -> [(t, PropBDD.Prop)]
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ @ t
                   (ds :: SPL.Var t)
                   (pc :: SPL.PresenceCondition) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.subst} True True} GHC.List.filter
                                                                                    @ (t,
                                                                                       PropBDD.Prop)
                                                                                    (\ (ds1 :: (t,
                                                                                                PropBDD.Prop)) ->
                                                                                     case ds1 of wild { (,) ds2 pc' ->
                                                                                     {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.subst.\} True True} let {
                                                                                                                                                          p :: PropBDD.Prop
                                                                                                                                                          = PropBDD.conj
                                                                                                                                                              (GHC.Types.:
                                                                                                                                                                 @ PropBDD.Prop
                                                                                                                                                                 pc
                                                                                                                                                                 (GHC.Types.:
                                                                                                                                                                    @ PropBDD.Prop
                                                                                                                                                                    pc'
                                                                                                                                                                    (GHC.Types.[]
                                                                                                                                                                       @ PropBDD.Prop)))
                                                                                                                                                        } in
                                                                                                                                                        {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:PropBDD.sat} True True} Cudd.Cudd.$fEqDDNode1
                                                                                                                                                                                                                             p `cast`
                                                                                                                                                                                                                             (Cudd.Cudd.N:DDNode[0])
                                                                                                                                                                                                                             PropBDD.disj1 })
                                                                                    ds
                                                                                      `cast`
                                                                                    (SPL.N:Var[0]
                                                                                         <t>_R)) -}
50373db62dc2230495c653d4f83b65f4
  undefinedAt :: SPL.Var t -> SPL.PresenceCondition
  {- Unfolding: InlineRule (0, True, True)
                SPL.undefinedAt1
                  `cast`
                (forall (t :: <*>_N).
                 <SPL.Var t>_R ->_R Sym (Cudd.Cudd.N:DDNode[0])) -}
4cab2e691be6f37c7f115bd5f6264615
  undefinedAt1 ::
    SPL.Var t -> GHC.ForeignPtr.ForeignPtr Cudd.C.CDDNode
  {- Unfolding: (\ @ t ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.undefinedAt} True False} \ (x :: SPL.Var
                                                                                                   t) ->
                                                                                         {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.undefinedAt} False True} PropBDD.impl1
                                                                                                                                                                   (SPL.definedAt
                                                                                                                                                                      @ t
                                                                                                                                                                      x)) -}
0fbaa2c5bc8ee839204cf72c8bb18df3
  union :: SPL.Var t -> SPL.Var t -> SPL.Var t
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (0, True, True)
                SPL.union1
                  `cast`
                (forall (t :: <*>_N).
                 <SPL.Var t>_R ->_R <SPL.Var t>_R ->_R Sym (SPL.N:Var[0] <t>_R)) -}
10f5100ab70827e2244ee605e22ff48c
  union1 :: SPL.Var t -> SPL.Var t -> [(t, SPL.PresenceCondition)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ t (ds :: SPL.Var t) (ds1 :: SPL.Var t) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.union} True True} GHC.Base.augment
                                                                                    @ (t,
                                                                                       SPL.PresenceCondition)
                                                                                    (\ @ b
                                                                                       (c :: (t,
                                                                                              SPL.PresenceCondition)
                                                                                             -> b
                                                                                             -> b)[OneShot]
                                                                                       (n :: b)[OneShot] ->
                                                                                     GHC.Base.foldr
                                                                                       @ (t,
                                                                                          SPL.PresenceCondition)
                                                                                       @ b
                                                                                       c
                                                                                       n
                                                                                       ds
                                                                                         `cast`
                                                                                       (SPL.N:Var[0]
                                                                                            <t>_R))
                                                                                    ds1
                                                                                      `cast`
                                                                                    (SPL.N:Var[0]
                                                                                         <t>_R)) -}
2f8e59b1970ed69903b4ca5a008226ed
  union2 :: SPL.Var (SPL.Var t) -> SPL.Var t
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ t (ds :: SPL.Var (SPL.Var t)) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.union2} True True} let {
                                                                                     xs :: [SPL.Var
                                                                                              t]
                                                                                     = GHC.Base.map
                                                                                         @ (SPL.Var
                                                                                              t,
                                                                                            SPL.PresenceCondition)
                                                                                         @ (SPL.Var
                                                                                              t)
                                                                                         (SPL.union4
                                                                                            @ t)
                                                                                         ds
                                                                                           `cast`
                                                                                         (SPL.N:Var[0]
                                                                                              <SPL.Var
                                                                                                 t>_R)
                                                                                   } in
                                                                                   ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.unions} True True} SPL.union3
                                                                                                                                                        @ t
                                                                                                                                                        xs)
                                                                                     `cast`
                                                                                   (Sym (SPL.N:Var[0]
                                                                                             <t>_R))) -}
39dc9190288b686aab38a4f958423dd9
  union3 :: [SPL.Var t] -> [SPL.Val t]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
3688f21bf15a1039464364366d0d3fdf
  union4 :: (SPL.Var t, SPL.PresenceCondition) -> SPL.Var t
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: (SPL.Var t, SPL.PresenceCondition)) ->
                 case ds of wild { (,) x pc ->
                 ({__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.union2.\} True True} SPL.cond'2
                                                                                        @ t
                                                                                        pc
                                                                                        x)
                   `cast`
                 (Sym (SPL.N:Var[0] <t>_R)) }) -}
9f1839cdabf504accea01f3051cc837a
  unions :: [SPL.Var t] -> SPL.Var t
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                SPL.unions1
                  `cast`
                (forall (t :: <*>_N).
                 <[SPL.Var t]>_R ->_R Sym (SPL.N:Var[0] <t>_R)) -}
3438c64dd4355cf99ecfecf49935311d
  unions1 :: [SPL.Var t] -> [SPL.Val t]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ t (xs :: [SPL.Var t]) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.unions} True True} SPL.union3
                                                                                     @ t
                                                                                     xs) -}
5d3f62abe03763494356c788dce7f31e
  valIndex :: GHC.Classes.Eq t => SPL.Var t -> t -> [SPL.Val t]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t ($dEq :: GHC.Classes.Eq t) (ds :: SPL.Var t) (x :: t) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.valIndex} True True} GHC.Base.build
                                                                                       @ (t,
                                                                                          SPL.PresenceCondition)
                                                                                       (\ @ b
                                                                                          (c :: (t,
                                                                                                 SPL.PresenceCondition)
                                                                                                -> b
                                                                                                -> b)[OneShot]
                                                                                          (n :: b)[OneShot] ->
                                                                                        GHC.Base.foldr
                                                                                          @ (t,
                                                                                             SPL.PresenceCondition)
                                                                                          @ b
                                                                                          (GHC.List.filterFB
                                                                                             @ (t,
                                                                                                SPL.PresenceCondition)
                                                                                             @ b
                                                                                             c
                                                                                             (\ (ds1 :: (t,
                                                                                                         SPL.PresenceCondition)) ->
                                                                                              case ds1 of wild { (,) x' pc' ->
                                                                                              {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.valIndex.\} True True} GHC.Classes.==
                                                                                                                                                                      @ t
                                                                                                                                                                      $dEq
                                                                                                                                                                      x'
                                                                                                                                                                      x }))
                                                                                          n
                                                                                          ds
                                                                                            `cast`
                                                                                          (SPL.N:Var[0]
                                                                                               <t>_R))) -}
99c1d38701c117cd8b469df7394e70bb
  (|+|) :: GHC.Num.Num a => SPL.Var a -> SPL.Var a -> SPL.Var a
  {- Arity: 1, Strictness: <L,1*U(1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.|+|} True True} SPL.liftV2
                                                                                  @ a
                                                                                  @ a
                                                                                  @ a
                                                                                  (GHC.Num.+
                                                                                     @ a
                                                                                     $dNum)) -}
7133b3c668037f8e35bd03ff7176ac35
  (|:|) :: SPL.Var a -> SPL.Var [a] -> SPL.Var [a]
  {- Unfolding: (\ @ a ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.|:|} True True} SPL.liftV2
                                                                                  @ a
                                                                                  @ [a]
                                                                                  @ [a]
                                                                                  (GHC.Types.:
                                                                                     @ a)) -}
18afba332cc40b3ad13d783f8a5b86c4
  (|==|) ::
    GHC.Classes.Eq a =>
    SPL.Var a -> SPL.Var a -> SPL.Var GHC.Types.Bool
  {- Arity: 1, Strictness: <L,1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) ->
                 {__scc {SPL-0.1.0.0-7EAm8K7cadUG9BMDvVycjL:SPL.|==|} True True} SPL.liftV2
                                                                                   @ a
                                                                                   @ a
                                                                                   @ GHC.Types.Bool
                                                                                   (GHC.Classes.==
                                                                                      @ a
                                                                                      $dEq)) -}
instance GHC.Base.Applicative [SPL.Var] = SPL.$fApplicativeVar
instance GHC.Classes.Eq [SPL.Var] = SPL.$fEqVar
instance GHC.Base.Functor [SPL.Var] = SPL.$fFunctorVar
instance GHC.Classes.Ord [SPL.Var] = SPL.$fOrdVar
instance GHC.Show.Show [SPL.Var] = SPL.$fShowVar
"SC:getAllConfigs0" forall (sc :: Cudd.Cudd.DDNode)
                           (sc1 :: [Cudd.Cudd.DDNode])
  SPL.getAllConfigs (GHC.Types.: @ PropBDD.Prop sc sc1)
  = SPL.getAllConfigs_$sgetAllConfigs sc sc1
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

