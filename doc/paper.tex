\documentclass[10pt,conference]{llncs}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
%\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{bussproofs}
\usepackage{minted}
\usepackage{stmaryrd}

\newcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Automatically Lifting Functional Software Analyses to Product Lines}

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{{Ramy Shahin\inst{1}} \and
	    {Marsha Chechik\inst{1}}}
	    
\institute{Computer Science Department\\
	University of Toronto\\
	\email\{rshahin,chechik\}@cs.toronto.edu}



% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
TODO
\end{abstract}

% no keywords


\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]

\newcommand{\tab}{\qquad}

% mathematical object definition
\newcommand{\term}[1]		{\mathrm{#1}}
\newcommand{\var}[1]		{\mathrm{#1}}
\newcommand{\type}[1]		{\mathrm{#1}}
\newcommand{\kw}[1]		{\mathrm{#1}}
\newcommand{\ite}[3]		{\kw{if} \: #1 \: \kw{then} \: #2 \: \kw{else} \: #3}

\section{Introduction}

%Software Product Lines (SPLs) are configurable sets of software artifacts from which different software products can be generated. SPLs, pretty much like classic manufacturing product lines, are much more economic in terms of time and effort, compared to developing and maintaining different software product variations separately. This is the reason why SPLs are becoming commonly adopted in many software domains, including operating systems, embedded systems, compilers and many others.

%SPLs capture product variability in several ways, including annotative mechanisms available in conventional programming languages. One of the most commonly used annotative mechanisms is C preprocessor macro definitions and conditional compilation. Product features are abstracted in terms of preprocessor macros, and feature selection is done using build-time macro definitions. This approach, although ad-hoc compared to more structural approaches provided by SPL language (e.g. Featured-oriented languages), has the benefit of not requiring any tools beyond the conventional C toolchain. 

\section{Background}

\subsection{Software Product Lines}

Given a set of features $F$:
\begin{itemize}
	\item $P[F]$ is the set of propositional formulas over $F$
	\item $sat:P[F] \to boolean$, \[ sat(p) = \begin{cases}
			true\ \text{if p is propositionally satisfiable} \\
			false\ \text{otherwise}
		\end{cases} \]
	\item $unsat:P[F] \to boolean$, \[ unsat(p) = \begin{cases}
			true\ \text{if p is propositionally unsatisfiable} \\
			false\ \text{otherwise}
		\end{cases} \]

\end{itemize}

A product line $P$ it a tuple $<F,\Phi,D,\phi>$ where:
\begin{itemize}
	\item $F$ is a set of features
	\item $\Phi \in P[F]$ (the feature model) is a propositional formula over $F$
	\item $D$ (the domain model) is a set of domain elements
	\item $\phi : D \to P[F]$ is a total function mapping each domain elements to a propositional formula over $F$, known as a Presence Condition(PC)
\end{itemize}

\subsection{Typed Lambda Calculus}

This is a summary of the TLC syntax and semantics from~\cite{Pierce2002}.

\subsubsection{Syntax}

\begin{center}
\begin{tabular}{ l r}
$\term{t} ::=$                                           	&	\tab (terms)		\\
\tab 	$\var{x}$						&	\tab variable		\\
\tab	$\lambda \var{v}:\type{T} .\term{t}$	&	\tab abstraction		\\	
\tab	$\term{t} \:  \term{t}$ 				&	\tab application		\\
\\
$\var{v} ::=$						&	\tab (values)		\\
\tab	$\lambda \var{v}:\type{T} .\term{t}$	&	\tab abstraction	value\\
\\
$T ::=$							&	\tab (types)		\\
\tab $...$							&	\tab primitive types	\\
\tab	$T \to T$						&	\tab type of functions \\
\\
$\Gamma ::=$						&	\tab (contexts)		\\
\tab 	$\Phi$						&	\tab empty context	\\
\tab	$\Gamma, \var{x}:\type{T}$		&	\tab term variable binding	\\
\\	
\end{tabular}
\end{center}

\subsubsection{Semantics}

\begin{prooftree}
\AxiomC{$\term{t}_1 \to \term{t}_1'$}
\RightLabel{(E-App1)}
\UnaryInfC{$\term{t}_1 \: \term{t}_2 \to \term{t}_1' \:  \term{t}_2$}	
\end{prooftree} 

\begin{prooftree}
\AxiomC{$\term{t}_2 \to \term{t}_2'$}
\RightLabel{(E-App2)}
\UnaryInfC{$\var{v}_1 \: \term{t}_2 \to \var{v}_1 \:  \term{t}_2'$}	
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{E-AppAbs}
\UnaryInfC{$(\lambda \var{x} . \term{t}) \var{v}_2 \to [\var{x} \mapsto \var{v}_2] \term{t}$}
\end{prooftree}

\subsubsection{Typing}

\begin{prooftree}
\AxiomC{$\var{x}:\type{T} \in \Gamma$}
\RightLabel{T-Var}
\UnaryInfC{$\Gamma \vdash \var{x}:\type{T}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma, \var{x}:\type{T_1} \vdash \term{t_2}:\type{T_2}$}
\RightLabel{T-Abs}
\UnaryInfC{$\Gamma \vdash \lambda \var{x}:\type{T_1}.\term{t_2} : \type{T_1} \to \type{T_2}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash \term{t_1}:\type{T_1} \to \type{T_2}$}
\AxiomC{$\Gamma \vdash \term{t_2}:\type{T_1}$}
\RightLabel{T-App}
\BinaryInfC{$\Gamma \vdash \term{t_1} \: \term{t_2} : \type{T_2}$}
\end{prooftree}

\subsection{Functional Software Analyses}
We assume that a Software Analysis is a TLC program $G$ that analyzes a single instance of product line $L$. 


\section{Lifting Typed Lambda Calculus}

The goal of this work is to automatically lift functional software analyses to work on product lines rather than individual product instances. Since we assume that functional analyses are written in TLC, then we just need to provide sound syntactic transformation rules that lift each of the TLC syntactic constructs. Those transformation rules can be applied to any software analysis written in TLC, resulting in an equivalent analysis that can be applied to a Software Product Line.

In the following description of the transformation rules we use Haskell syntax. This way we can use several functional constructs (parametric types, lists, pairs) without loss of generality, as those constructs have standard definitions on top of TLC~\cite{Pierce2002}.

When lifting an analysis from products to product lines, we need to appropriately tag values with their corresponding presence conditions. We use the \emph{PresenceCondition} abstract data type for this purpose.

\subsection{Lifting Types}
Given a type \textbf{t}, we lift it into type \textbf{Var t} which is:

\begin{minted}{haskell}
type Var t = [(Maybe t, PresenceCondition)]
\end{minted}

where:
\begin{itemize}
\item \textbf{t} is a type parameter that can be instantiated with any type
\item \textbf{Maybe t} is  an Option type. Elements of this type are either \textbf{Nothing}, or \textbf{Just x}, where \textbf{x} is of type \textbf{t}. We use an option type because a value does not necessarily have to exist in all products of the product line.
\item \textbf{(Maybe t, PresenceCondition)} is a pair of a value of type \textbf{t} together with a \textbf{PresenceCondition}
\item \textbf{[(Maybe t, PresenceCondition)]} is a list of such pairs
\item \textbf{Var t $\equiv$ [(Maybe t, PresenceCondition)]} is a parametric data type, instantiated by passing the type argument \textbf{t} to the type constructor \textbf{Var}
\end{itemize}

A variable of type \textbf{t} in a product line might actually have different values in different products, hence the multiplicity of items in a list. The \textbf{PresenceCondition} tags are used to keep track of which values correspond to which products. For this to be semantically correct we need to make sure that the sets of products represented by those presence conditions do not overlap, otherwise we might end up with a product variable having different values at the same time. This \textbf{disjointness} requirement is formalized in the following invariant:

\newtheorem*{disjInv*}{Disjointness Invariant}
\begin{disjInv*}
Given a lifted value $v = [(v_0, pc_0), ... (v_n, pc_n)]$, $\forall i \neq j: {unsat (pc_i \wedge pc_j)}$
\end{disjInv*}

The invariant simply states that a lifted value can not have different values with presence condition that overlap. The \emph{unsat} function takes a proposition and returns true if and only if that proposition is unsatisfiable. The conjunction of two presence conditions is unsatisfiable if and only if they represent non-overlapping sets of products.

This invariant is a precondition on inputs into the program being lifted, and in the following sections we will show how its validity is maintained by the lifting transformations.

Another invariant is that a \textbf{Var t} value covers the full product space:

\newtheorem*{covInv*}{Full Coverage Invariant}
\begin{covInv*}
Given a lifted value $v = [(v_0, pc_0), ... (v_n, pc_n)]$, $\bigvee_{i} pc_i = \top $
\end{covInv*}

This invariant is not necessary for soundness, but it makes formal treatment of this framework more straightforward. It simply states that the presence conditions of a \textbf{Var t} value form a partition of the truth assignments over the feature set $F$.

\subsection{Lifting Values}

To lift a value of type \textbf{t}, all we need to is to provide a presence condition for it, and then encapsulate both into a value of type \textbf{Var t}. This is what the following \textbf{lift} operator does:

\begin{minted}{haskell}
lift :: PresenceCondition -> t -> Var t
lift pc x = [(Just x,pc), (Nothing, neg pc)]
\end{minted}

This operator can be applied to values of any type, including functions. The importance of lifting function values will be clear in the following subsection.

In many cases we need to provide the most general presence condition, which is \textbf{True} (the set of all products). For this we provide the following \textbf{liftT} operator:

\begin{minted}{haskell}
liftT :: t -> Var t
liftT x = lift True x
\end{minted}

Input values to analyses from product lines will typically be of lifted types. For example, an integer can have one value in a set of products, and a different value in another set. 

\begin{exmp}[Lifted Values]

Assuming we have two features A and B, variables x and y of type \textbf{Var Int} and variable z of type \textbf{Var String} can have the following values: \\

x = [(Just 1,A),(Just (-2), $\neg A \wedge B$),(Just 3, $\neg A \wedge \neg B$)]

y = [(Just 5, $A \wedge \neg B$), (Just 4,B), (Just (-3), $\neg A \wedge \neg B$)]

z = [(Just "hello", $\neg A \wedge B$),(Just "helloooo", A), (Nothing, $\neg A \wedge \neg B$] \\

\end{exmp}

\subsection{Applying Lifted Functions}

Now that we have lifted values (both data and functions), we need to provide a way to apply lifted functions to lifted operands. This is how data propagates through a functional program. Starting with the simplest case, where we have a lifted unary function of type \textbf{Var (a $\to$ b)} and an argument of type \textbf{Var a} we need to provide a way to apply that function to its argument resulting in a \textbf{Var b} value.

Recall that a lifted value of type \textbf{Var t} is just a collection of values of type \textbf{t}, each with a corresponding presence condition, and the whole lifted value has to satisfy the disjointness Invariant. So to apply a collection of functions to a collection of values, all we need to is to apply each of the functions to each of the values. Since the result has to be a lifted value, then we also need a presence condition for each of the computed values. This presence condition is simply the conjunction of the presence conditions of the function and the argument used to compute it. If the conjunction of the presence conditions is unsatisfiable (i.e. a contradiction), it means that the corresponding value does not belong to any product, so it can be safely filtered out. This is how the apply function looks in Haskell:

\begin{minted}{haskell}
apply :: Var (a -> b) -> Var a -> Var b
apply (Var fn) (Var x) =
  Var [(case (fn', x') of
    (Just fn'', Just x'') -> Just (fn'' x'')
    (_,_) -> Nothing
  , pc) 
       | (fn', fnpc) <- fn,
         (x', xpc) <- x,
         let pc = conj[fnpc, xpc],
         (sat pc)]
\end{minted}

\begin{exmp}[Unary function application]

Assume that we need to be apply the absolute value function (\emph{abs}) to the lifted variable \emph{x} from the previous example. Since \emph{x} is lifted, we need a lifted version of \emph{abs}, which we can simply get by using the liftT function:

\begin{minted}{haskell}
liftedAbs = liftT abs
\end{minted}

Now we can apply \emph{liftedAbs} to \emph{x}:

\begin{minted}{haskell}
abs_x = apply liftedAbs x
\end{minted}

The \emph{apply} function applies a lifted function to a lifted value (of matching type), resulting in a lifted value. In this example, the result \emph{abs\_x} will have the value: \\

[(Just 1,A),(Just 2, $\neg A \wedge B$), (Just 3, $\neg A\wedge \neg B$)].

\end{exmp}

\begin{exmp}[Binary function application]

Now assume that we would like to add \emph{x} and \emph{y}. The first step is to get a lifted version of the (+) operator:

\begin{minted}{haskell}
plus = (+)
liftedPlus = liftT plus
\end{minted}

The function \emph{apply} takes a function and a single argument, so how do we extend it beyond unary functions?

Actually this is no different from functions in TLC, where all functions are unary, and functions of higher arities are just Curried higher-order functions \cite{Pierce2002}. If we pass \emph{liftedPlus} and \emph{x} to apply, it will apply the binary lifted operator \emph{liftedPlus} to a single lifted argument \emph{x}:

\begin{minted}{haskell}
intermediateVal = apply liftedPlus x
\end{minted}

But since multi-parameter functions are actually Curried unary functions, \emph{intermediateVal} is a lifted unary function [(Just (plus 1), A),(Just (plus -2), $\neg A \wedge B$),(Just (plus 3), $\neg A \wedge \neg B$)].

Now we just need to apply \emph{intermediateVal}, which is actually a lifted unary function, to \emph{y}:

\begin{minted}{haskell}
finalVal = apply intermediateVal y
\end{minted}

The result in \emph{finalVal} is: \\

[(Just 6, $A \wedge \neg B$), (Just 5, $A \wedge B$), (Just 2, $\neg A \wedge B$), (Just 0, $\neg A \wedge \neg B$)] \\

Recall that apply generates the cross product of its arguments (each of them a list of values labeled with presence conditions), and excludes the pairs where the conjunction of presence conditions is not satisfiable. This is why finalVal has only four possible values, although the cross product initially had 9.

As a shortcut, we can define a binary version of \emph{apply} (let us call it \emph{apply2}) that implements this pattern of partial function application and Currying:

\begin{minted}{haskell}
apply2 :: Var (a -> b -> c) -> 
	  Var a -> Var b -> Var c
apply2 fn a b = apply (apply fn a) b
\end{minted}

Versions of \emph{apply} for functions of other aritiies  can be defined similarly:

\begin{minted}{haskell}
apply3 :: Var (a -> b -> c -> d) -> 
          Var a -> Var b -> Var c -> Var d
apply3 fn a b c = apply (apply2 fn a b) c
...
\end{minted}

\end{exmp}

\begin{exmp}[Conditional Expression]

An \emph{if-then-else} expression is just syntactic sugar for a ternary polymorphic function, taking a boolean argument and two arguments of type \emph{t} and returning one of them depending on what the first argument evaluates to. We can easily de-sugar \emph{if-then-else} expressions into the following \emph{cond} function:

\begin{minted}{haskell}
cond :: Bool -> t -> t -> t
cond p a b = if p then a else b
\end{minted}

Now lifting a conditional expression is no different from lifting any other function:

\begin{minted}{haskell}
condLifted = apply3 (liftT cond)
\end{minted}

So for example the expression

\begin{minted}{haskell}
if (x == y) then (x + y) else (x - y)
\end{minted}

Is lifted into:

\begin{minted}{haskell}
liftedEq    a b = apply2 (liftT (==)) a b
liftedPlus  a b = apply2 (liftT (+))  a b
liftedMinus a b = apply2 (liftT (-))  a b

condLifted (liftedEq x y) 
           (liftedPlus x y) 
           (liftedMinus x y)
\end{minted}

Please note that Haskell's lazy evaluation makes the de-sugared \emph{cond} function semantically equivalent to a conditional expression because only one of the \emph{then} and \emph{else} expressions is evaluated after the boolean condition is evaluated based on its truth value. However, a language with strict evaluation semantics would evaluate both the \emph{then} and \emph{else} expressions before they are passed to \emph{cond}. This is still fine if both expressions are pure (with no side-effects). However, if any of the expression has side effects, the equivalence between \emph{cond} and the typical conditional expression is broken.

\end{exmp}

%\subsubsection{Lifting Composite Types}

%\subsubsection{Function Rewriting}

%\subsection{Lifting Parametric Types}

%\section{Formal Definitions and Theorems}

%\subsection{Definitions}
%\subsubsection{Product Line Values}
%Given a type $t \in T$,  a value $\var{v}$ of type $\type{t}$, and the presence condition of $\var{v}$ is $\var{pc}$, then the pair $(\var{v}, \term{pc})$ is of the polymorphic type $\type{SPLVal} \: \type{t}$.

%\begin{prooftree}
%\AxiomC{$\type{t} \in T$}
%\AxiomC{$\var{v}:\type{t}$}
%\AxiomC{$\phi (\var{v}) = \term{pc}$}
%\RightLabel{(T-SPLVal)}
%\TrinaryInfC{$(\var{v}, \term{pc}) : \type{(SPLVal \: \type{t})}$}	
%\end{prooftree}

%\begin{minted}{haskell}
%type SPLVal t = (t, PresenceCondition)
%\end{minted}

%\subsubsection{Product Line Variables}

%Given a type $t \in T$, the set $\{(x_1, pc_1),...,(x_n, pc_n)\}$ is of type $(\type{SPLVar} \: \type{t})$, where:
%\begin{itemize}
%\item $\forall i, (x_i, pc_i) : (\type{SPLVal} \: \type{t})$ (Correctness)
%\item $\forall (i \neq j), {unsat(\var{pc}_i \wedge \var{pc}_j)}$ (Disjointness)
%\end{itemize}

%\begin{prooftree}
%\AxiomC{$\type{t} \in T$}
%\AxiomC{$(\var{x_1}, \var{pc_1}), ... , (\var{x_n}, \var{pc_n}) : (\type{SPLVal} \: \type{t})$}
%\AxiomC{$\forall (i \neq j), {unsat(\var{pc}_i \wedge \var{pc}_j)}$}
%\RightLabel{(T-SPLVar)}
%\TrinaryInfC{$\{(x_1, pc_1),...,(x_n, pc_n)\} : (\type{SPLVar} \: \type{t})$}	
%\end{prooftree}

%\begin{minted}{haskell}
%type SPLVar t = [SPLVal t]
%\end{minted}

%\newtheorem*{prodValid*}{Product Validity}
%\begin{prodValid*}
%Given an SPLVar $v = [(v_0, pc_0), ... (v_n, pc_n)]$, $\forall i: {pc_i \Rightarrow \Phi}$
%\end{prodValid*}

%\newtheorem*{correctness*}{Correctness}
%\begin{correctness*}
%Given an SPLVar $v'$ that corresponds to a single-product variable $v$ in $G$, $(x,pc) \in v' \Leftrightarrow \forall e:{(e \Rightarrow pc) \Rightarrow G(e) \llbracket v \rrbracket = x}$
%\end{correctness*}

%\newtheorem*{disjInv*}{Disjointness}
%\begin{disjInv*}
%Given an SPLVar $v = [(v_0, pc_0), ... (v_n, pc_n)]$, $\forall i \neq j: {unsat (pc_i \wedge pc_j)}$
%\end{disjInv*}

%\subsubsection{Function Definition}
%Given a function $\var{f} : \type{a_1} \to ... \to \type{a_n} \to \type{b}$ where $\exists i, \type{a_i} \in T$, \\
%we define $\var{f'} : \type{SPLVar} \: (\type{a_1} \to ... \to \type{a_n} \to \type{b})$, where $\var{f'} = \{(\var{f}, True)\}$

%\begin{prooftree}
%\AxiomC{$\var{f} : \type{a_1} \to ... \to \type{a_n} \to \type{b}$}
%\AxiomC{$\exists i, \type{a_i} \in T$}
%\RightLabel{(T-SPLVar-f)}
%\BinaryInfC{$\var{f'} : \type{SPLVar} \: (\type{a_1} \to ... \to \type{a_n} \to \type{b}) = \{(\var{f}, True)\}$}	
%\end{prooftree}

%\begin{minted}{haskell}
%f' :: SPLVar (a -> b)
%f' = [(f, True)]
%\end{minted}

%Here the newly defined SPL function variable $f'$ is a singleton wrapper of the original function $f$, and making it applicable to all products. The SPLVar $f'$ obviously satisfies the disjointness condition, and because it is a fresh variable that does not exist in $G$ the correctness condition does not apply to it.

%\subsubsection{Function Application}

%Given a function $\var{f'} : \type{SPLVar} \: (\type{a} \to \type{b})$ 
%and a variable $\var{x} : (\type{SPLVar} \: \type{a})$, 
%the result of applying $\var{f'}$ to $\var{x}$ is the set 
%$\{(\var{f''}(\var{x'}), \var{fpc} \wedge \var{xpc}) \: | \: (\var{f''}, \var{fpc}) \in \var{f'}, (\var{x'}, \var{xpc}) \in x, sat(\var{fpc} \wedge \var{xpc})\}$

%\begin{prooftree}
%\AxiomC{$\var{f'} : \type{SPLVar} \: (\type{a} \to \type{b})$}
%\AxiomC{$\var{x} : (\type{SPLVar} \: \type{a})$}
%\RightLabel{(E-SPL-apply)}
%\BinaryInfC{$(\var{apply} \: \var{f'} \: \var{x}) = \{(\var{f''}(\var{x'}), \var{fpc} \wedge \var{xpc}) \: | \: (\var{f''}, \var{fpc}) \in \var{f'}, (\var{x'}, \var{xpc}) \in x, sat(\var{fpc} \wedge \var{xpc})\}$}	
%\end{prooftree}

%\begin{minted}{haskell}
%apply :: SPLVar (a -> b) -> SPLVar a -> SPLVar b
%apply fn x = [(fnVal xVal, conj [fnPC,xPC]) 
%              | (fnVal,fnPC) <- fn, (xVal,xPC) <- x, sat(conj[fnPC,aPC])] 
%\end{minted}

%Here we are using Haskell's list comprehension syntax to build the (SPLVar b) result of applying a lifted function to a single argument of type (SPLVar a). The function \textbf{conj} takes a list of presence conditions and returns their conjunction, and the function \textbf{sat} takes a presence condition (a symbolic proposition in general) and returns true if its argument is satisfiable, otherwise it returns false.

%As in almost all functional programming languages, Currying is the standard mechanism to extend application of single-argument functions to multi-argument functions. We provide versions of apply for different arities:

%\begin{minted}{haskell}
%apply2 :: SPLVar (a -> b -> c) -> SPLVar a -> SPLVar b -> SPLVar c
%apply2 fn a = apply (apply fn a)

%apply3 :: SPLVar (a -> b -> c -> d) -> SPLVar a -> SPLVari b -> SPLVar c -> SPLVar d
%apply3 fn a b = apply (apply2 fn a b)
%\end{minted}

\subsection{Theorems}

\subsubsection{Application Preserves Disjointness}

\newtheorem{th1}{Theorem}
\begin{th1}
If f and x satisfy the disjointness condition, then the result of (apply f x) also satisfies disjointness.
\end{th1}

\begin{proof}

By contradiction:

\begin{itemize}
\item Assume that both f and x satisfy disjointness while the result y = (apply f x) does not
\item Then there exists at least one pair of presence conditions in y ($pc_i$ and $pc_j$) where sat($pc_i \wedge pc_j$) = true
\item Each of $pc_i$ and $pc_j$ is a conjunction of presence conditions from f and x (definition of apply), then for arbitrary a, b, c and d: \\
               $pc_i = fpc_a \wedge xpc_b$ \\
               $pc_j = fpc_c \wedge xpc_d$
\item Then $pc_i \wedge pc_j = pc_a \wedge xpc_b \wedge fpc_c \wedge xpc_d$
\item For this conjunction to be satisfiable, we must have both sat($fpc_a \wedge xpc_b$) and sat($fpc_c \wedge xpc_d$), which contradicts the assumption that f and x both satisfy disjointness
\item Then y = (apply f x) must satisfy disjointness too
\end{itemize}

\end{proof}

\subsubsection{Application Preserves Correctness}

\newtheorem{th2}{Theorem}
\begin{th2}
If f' and x' satisfy the correctness condition with respect to original variables f and x respectively, then the result of (apply f' x') also satisfies correctness with respect to (f x).
\end{th2}

\begin{proof}
Given v' = (apply f' x'), we need to prove that $(y, pc) \in v' \Leftrightarrow \forall e:{(e \Rightarrow pc) \Rightarrow G(e) \llbracket f(x) \rrbracket = y}$
\begin{itemize}
\item{$\Rightarrow$}
	\begin{itemize}
	\item Assume that $(y,pc) \in v'$ and for some arbitrary truth assignment $e$, $e \Rightarrow pc$
	\item Then by definition of apply, there exists $(f'', fpc) \in f'$, $(x'', xpc) \in x$, such that y = f''(x'') and pc = $fpc \wedge xpc$
	\item Since $e \Rightarrow pc$, then $e \Rightarrow fpc \wedge xpc$, which means that $e \Rightarrow fpc$ and $e \Rightarrow xpc$
	\item By definition of $G(e)$ and the assumption that both f' and x' satisfy the correctness condition, $G(e) \llbracket f \rrbracket = f'$, and $G(e) \llbracket x \rrbracket = x'$
	\item Then $G(e) \llbracket f(x) \rrbracket = y$
	\end{itemize}
\item{$\Leftarrow$}
	\begin{itemize}
	\item Assume $\forall e:{(e \Rightarrow pc) \Rightarrow G(e) \llbracket f(x) \rrbracket = y}$
	\item Then given an arbitrary truth assignment $e$ (identifying a single product) where $e \Rightarrow pc$, $G(e) \llbracket f(x) \rrbracket = y$
	\item Since f' and x' are both assumed to satisfy the disjointness and correctness conditions, then $(f,fpc) \in f'$ and $(x,xpc) \in x'$ where $pc = fpc \wedge xpc$
	\item Then by definition of apply, $(y,pc) \in$ (apply f' x')
	\end{itemize}
\end{itemize}

\end{proof}

\section{Evaluation}

\subsection{LTS Reachability with Witness}

%\subsection{TODO: Some other analysis}

%\section{Discussion}
%\subsection{Deep vs Shallow Lifting}

\section{Related Work}
TODO



\section{Conclusion}
TODO



\bibliography{taxonomy} 
\bibliographystyle{splnc04}



% that's all folks
\end{document}

